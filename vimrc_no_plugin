" plugins
" source ~/.config/vim/options.vim
" source ~/.config/vim/keybinds.vim
" source ~/.config/vim/plugins.vim
" source ~/.config/vim/colors.vim
" " source ~/.config/vim/fzf.vim
" source ~/.config/vim/lightline.vim
" source ~/.config/vim/auto_pairs.vim
" source ~/.config/vim/syntax.vim
" " source ~/.config/vim/async_complete.vim
" source ~/.config/vim/nerdtree.vim
" " source ~/.config/vim/outline.vim
" colorscheme desert
" colorscheme koehler

filetype plugin indent on
set softtabstop=4
set smartindent
set showmatch
set termguicolors
syntax enable
syntax on
set t_Co=256

set noswapfile
set nobackup
set autoread
set autowrite
set confirm

" Line numbers
set number
set relativenumber
set ruler
set autowrite

" Indentation and tabs
set tabstop=4
set shiftwidth=4
set autoindent
set expandtab

" Search
set hlsearch
set ignorecase
set smartcase
set incsearch

" Appearance
set background=dark
set signcolumn=yes
set cursorline
set colorcolumn=80

" Backspace behavior
set backspace=indent,eol,start

" Split window behavior
set splitbelow
set splitright

" dw/diw/ciw treat dash-separated words as single word
set iskeyword+=-

" Keep cursor 8 lines from top/bottom
set scrolloff=8

set ttimeoutlen=0
" Cursor responsiveness
set updatetime=300

set laststatus=2

set shortmess=atI

set guifont=Menlo:h16

" Set leader key
let mapleader = ";"

" Open netrw with <leader>cd
nnoremap <leader>cd :Ex<CR>

" Move selected lines up/down (like Alt-Up/Down)
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" Join lines with cursor preserved
nnoremap J mzJ`z

" Scroll half-page and center cursor
nnoremap <C-d> <C-d>zz
nnoremap <C-u> <C-u>zz

" Center on next/previous search result
nnoremap n nzzzv
nnoremap N Nzzzv

" Paste without overwriting clipboard
" xnoremap <leader>p "_dP
" nnoremap <leader>d "_d
" vnoremap <leader>d "_d

" Make <C-c> behave like <Esc> in insert mode
inoremap <C-c> <Esc>

" Navigate quickfix list using Ctrl-j/k
nnoremap <C-j> :lnext<CR>
nnoremap <C-k> :lprev<CR>
nnoremap <leader>cl :lclose<CR>

" Disable Ex mode (accidental Q)
nnoremap Q <nop>

" Location list navigation
" nnoremap <leader>k :lnext<CR>zz
" nnoremap <leader>j :lprev<CR>zz

" Doge doc generator
nnoremap <leader>dg :DogeGenerate<CR>

" Substitute word under cursor on line
nnoremap <leader>s :s/\<<C-r><C-w>\>//gI<Left><Left><Left>

" Yank via OSCYank
" nmap <leader>y <Plug>OSCYankOperator
" vmap <leader>y <Plug>OSCYankVisual

" Reload vimrc (adjust path as needed)
nnoremap <leader>rl :source ~/.vim/vimrc<CR>

" Source current file
nnoremap <leader><leader> :so<CR>

" 不关闭文件推出
nmap <Leader>z <C-Z>
" 水平分隔
nmap <Leader>s :Sex<CR>
" 竖直分隔
nmap <Leader>v :Vex<CR>

" 定义快捷键 关闭当前分割窗口
nmap <Leader>q :q<CR>

" 定义快捷键
nmap <Leader>w :w<CR>

" 删除光标所在单词
nmap e daw

nmap <Leader>r :%s/a/b/gc
" 快速移动到行首，行尾
map <Leader>1 ^
map <Leader>2 $
nmap <Leader>u <C-U>
nmap <Leader>d <C-D>
" 设置快捷键gs遍历各分割窗口。快捷键速记法：goto the next spilt window
nnoremap <Leader>gg <C-W><C-W>
" 向左
nnoremap <leader>h <C-W><C-H>
" 向右
nnoremap <leader>l <C-W><C-L>
" 向上
nnoremap <Leader>k <C-W><C-K>
" 向下
nnoremap <Leader>j <C-W><C-J>

nmap <Leader>t :Tab /
inoremap <C-h> <Left>
inoremap <C-l> <Right>
inoremap <C-j> <Down>
inoremap <C-k> <Up>

nnoremap <leader>bd :bd<CR>

" shortcut for markdown
" 创建时间快捷键for markdown
" nmap tm :call SetTime() <CR>
" func SetTime()
        " call append(line("."), "\# ".strftime('%a %d %b %Y'))
" endfunc

" nmap tb :call SetTable() <CR>
" func SetTable()
        " call append(line("."), "\| | | ")
        " call append(line(".")+1, "\|---|---|")
        " call append(line(".")+2, "\| | |")
" endfunc

" nmap pc :call SetPic() <CR>
" func SetPic()
        " call append(line("."), "\<img src='' width=600 alt=''> </img></div>")
" endfunc

" nmap pi :call SetPic1() <CR>
" func SetPic1()
        " call append(line("."), "\![]()")
" endfunc

" nmap vi :call SetVideo() <CR>
" func SetVideo()
        " call append(line("."), "\<video src='1.mp4' controls='controls' width='640' height='320' autoplay='autoplay'> Your browser does not support the video tag.</video></div>")
" endfunc

" nmap cl :call SetCollor() <CR>
" func SetCollor()
        " call append(line("."), "<span  style='color: #f16707;'> </span>")
" endfunc


" nnoremap <leader>t :tabnew<CR>:term ++close bash<CR>
nmap <silent> ]<Space> o<ESC>
nmap <silent> [<Space> O<ESC>
nmap die ggdG$
nmap yie ggyG$
nmap vie ggvG$


nmap <Leader>r :%s/a/b/gc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" gvim/macvim设置
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("gui_running")
	set guifont=DroidSansMono\ Nerd\ Font\ Regular\ 14      " 设置字体
	set guioptions-=m           " 隐藏菜单栏
	set guioptions-=T           " 隐藏工具栏
	set guioptions-=L           " 隐藏左侧滚动条
	set guioptions-=r           " 隐藏右侧滚动条
	set guioptions-=b           " 隐藏底部滚动条
	set showtabline=0           " 隐藏Tab栏
	set guicursor=n-v-c:ver5    " 设置光标为竖线
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-buffer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <silent><c-p> :call <sid>ChangeBuffer('p')<cr>
nnoremap <silent><c-n> :call <sid>ChangeBuffer('n')<cr>
nnoremap <silent><S-Tab> :call <sid>ChangeBuffer('n')<cr>
nnoremap <silent><Tab>     :call <sid>ChangeBuffer('p')<cr>
nnoremap <silent><expr><c-m> &bt==''?":w<cr>":&bt=='terminal'?"i\<enter>":
			\ getwininfo(win_getid())[0]["quickfix"]!=0?"\<cr>:cclose<cr>":
			\ getwininfo(win_getid())[0]["loclist"]!=0?"\<cr>:lclose<cr>":"\<cr>"
nnoremap <silent><leader>d :call <sid>CloseBuf()<cr>
func! s:ChangeBuffer(direct) abort
	if &bt!=''||&ft=='netrw'|echoerr "buftype is ".&bt." cannot be change"|return|endif
	if a:direct=='n'|bn
	else|bp|endif
	while &bt!=''
		if a:direct=='n'|bn
		else|bp|endif
	endwhile
endfunc
func! s:CloseBuf()
	if &bt!=''||&ft=='netrw'|bd|return|endif
	let buf_now=bufnr()
	let buf_jump_list=getjumplist()[0]|let buf_jump_now=getjumplist()[1]-1
	while buf_jump_now>=0
		let last_nr=buf_jump_list[buf_jump_now]["bufnr"]
		let last_line=buf_jump_list[buf_jump_now]["lnum"]
		if buf_now!=last_nr&&bufloaded(last_nr)&&getbufvar(last_nr,"&bt")==''
			execute ":buffer ".last_nr|silent! execute ":bd ".buf_now|return
		else|let buf_jump_now-=1
		endif
	endwhile
	bp|while &bt!=''|bp|endwhile
	execute "bd ".buf_now
endfunc

" load vim default plugin
runtime macros/matchit.vim

" check version
if !has('patch-8.0.1453')
	echom "WARNING:vim is too old,so it can support some feature!"|finish
endif

" "update self
" command! -nargs=0 UpdateSelf echo "Updating,please wait..."|call system('curl https://gitee.com/mirrorvim/vim-fast/raw/master/shell/websimple.sh | bash')|qa

" "install binrary tools
" func! s:Askifaddpath()
	" echohl WarningMsg|if input("need to add to binrary path to $PATH?")=="y"|call system("echo 'export PATH=~/.local/bin:$PATH' >> ~/.bashrc")|endif|echohl NONE
" endfunc
" command! -nargs=0 Fzfinstalldeb     exec ":!sudo apt install -y fzf"
" command! -nargs=0 Fzfinstallweb     exec ":!wget https://gitee.com/mirrorvim/userful-tools-2/releases/download/cmdv1.0.0/fzf-0.36.0-linux_amd64.tar.gz;mkdir ~/.local;mkdir ~/.local/bin;tar -zxvf ./fzf-0.36.0-linux_amd64.tar.gz -C ~/.local/bin;rm ./fzf-0.36.0-linux_amd64.tar.gz"|redraw!|call <sid>Askifaddpath()
" command! -nargs=0 Nvrinstallweb     exec ":!mkdir -p ~/.config/nvim;wget https://gitee.com/mirrorvim/vim-fast/raw/master/shell/nvr.py -O ~/.config/nvim/nvr.py;chmod +x ~/.config/nvim/nvr.py"|redraw!|call <sid>Askifaddpath()
" command! -nargs=0 Ctagsinstalldeb   exec ":!sudo apt install -y ctags"
" command! -nargs=0 Ctagsinstallweb   exec ":!mkdir -p ~/.local/bin;wget https://gitee.com/mirrorvim/userful-tools-2/releases/download/ctagsv1.0.1/ctags -O ~/.local/bin/ctags;chmod +x ~/.local/bin/ctags"|redraw!|call <sid>Askifaddpath()
" command! -nargs=0 Lfinstallweb      exec ":!mkdir -p ~/.local/bin;wget https://gitee.com/mirrorvim/userful-tools-2/releases/download/lfv1.0.0/lf -O ~/.local/bin/lf;chmod +x ~/.local/bin/lf"|redraw!|call <sid>Askifaddpath()
" command! -nargs=0 Lazygitinstallweb exec ":!mkdir -p ~/.local/bin ~/.config/lazygit;wget https://gitee.com/mirrorvim/userful-tools-2/releases/download/cmdv1.0.0/lazygit.tar.gz;tar -zxvf ./lazygit.tar.gz -C ~/.local/bin;mv ~/.local/bin/config.yml ~/.config/lazygit/;rm ./lazygit.tar.gz"|redraw!|call <sid>Askifaddpath()
" command! -nargs=0 Rginstallweb exec ":!mkdir ~/.local;mkdir ~/.local/bin;wget https://gitee.com/mirrorvim/userful-tools-2/releases/download/rgv1.0.0/rg.tar.gz;tar -zxvf ./rg.tar.gz -C ~/.local/bin;mv ~/.local/bin/ripgrep-13.0.0-x86_64-unknown-linux-musl/rg ~/.local/bin/rg;rm -rf ./rg.tar.gz ~/.local/bin/ripgrep-13.0.0-x86_64-unknown-linux-musl"|redraw!|call <sid>Askifaddpath()

" 插入模式下的光标移动
imap <c-j> <down>
imap <c-k> <up>
imap <c-l> <right>
imap <c-h> <left>
" map enter
func! s:Enter()
	let ch=getline('.')[col('.')-1]|let last=getline('.')[col('.')-2]
	if ch=='}'&&last=='{'
		let str=matchstr(getline('.'),"^\\s*")
		call append(line('.'),str.ch)
		return "\<del>\<cr>"
	endif
	return "\<cr>"
endfunc
inoremap <silent><cr> <c-r>=<sid>Enter()<cr>

" 插入移动
inoremap <c-e> <end>
inoremap <c-a> <c-o>^
inoremap <c-d> <del>
vnoremap <c-d> <del>
inoremap <c-f> <c-o>w
inoremap <c-v> <c-o>D
inoremap <expr><c-b> <sid>CtrlB()
func! s:CtrlB()
	if pumvisible()|return "\<c-n>"
	elseif getline('.')[col('.')-2]==nr2char(9)
		let s:pos=col('.')|let s:result=""
		while s:pos!=0|let s:result=s:result."\<bs>"|let s:pos-=1|endwhile
		return s:result
	else
		return "\<c-o>b"
	endif
endfunc

" use jk map for esc
inoremap <C-c> <esc>

" select paste
snoremap <c-v> <space><bs><c-o>"0P

" 插入模式删除
inoremap <c-q> <c-o>dd
snoremap <c-q> <c-o>dd

" 定位装置
nnoremap <c-y> /{<cr>:noh<cr>va}<c-g>
nnoremap <c-t> ?}<cr>:noh<cr>va{<c-g>
inoremap <c-y> <c-[>/{<cr>:noh<cr>va}<c-g>
vnoremap <c-y> <c-[>/{<cr>:noh<cr>va}<c-g>
vnoremap <c-t> <c-[>?}<cr>:noh<cr>va{<c-g>
inoremap <c-t> <c-[>?}<cr>:noh<cr>va{<c-g>


" 复制当前选中到系统剪切板
vnoremap <leader><leader>y "+y
nnoremap <leader><leader>y "+y
"将系统剪切板内容粘贴到vim
nnoremap <leader><leader>p "+p
nnoremap <leader><leader>P "+P
vnoremap <leader><leader>p "+p
vnoremap <leader><leader>P "+P

augroup ReadPost
	au!
	autocmd BufEnter * redrawt
	autocmd QuickFixCmdPost * copen
	autocmd FileType java,c,cpp set commentstring=//\ %s
	if !has('nvim')
		autocmd TerminalOpen * if &bt=='terminal'|setlocal norelativenumber|setlocal nonumber|endif
	else
		autocmd WinEnter * if &bt=='terminal'&&!exists(':Termdebug')|call feedkeys("i\<esc>\<esc>")|endif
		autocmd TermOpen * if &bt=='terminal'|setlocal norelativenumber|setlocal nonumber|startinsert|endif
		autocmd TermClose * if !exists('g:nvim_term_open')|call feedkeys("i\<esc>\<esc>")|else|unlet g:nvim_term_open|endif
	endif
	autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | execute "normal! g'\"" | execute "normal! zz" | endif
	autocmd BufDelete * if expand('%:p')!=''&& &bt==""|let g:map_recent_close[expand('%:p')] =
				\{'lnum':line('.'),'col':col('.'),'text':'close at '.strftime("%H:%M"),'time':localtime()}
				\|endif
	autocmd MenuPopup * call RightMouseMenu()
augroup END

" 打开最近关闭的buffer
let g:map_recent_close={}
func! s:GetRecentClose()
	let s:list=[]
	for [key,value] in items(g:map_recent_close)
		let value['filename']=key
		call insert(s:list,value)
	endfor
	let s:func={m1,m2 -> m1['time']>m2['time']?-1:1}
	call sort(s:list,s:func)
	call setqflist(s:list,'r')
	copen
endfunc
nnoremap <silent><nowait><space>q :call <sid>GetRecentClose()<cr>

" termdebug
nnoremap <leader><leader>d :set mouse=a<cr>:packadd termdebug<cr>:Termdebug<space>
nnoremap <F5> :set mouse=a<cr>:packadd termdebug<cr>:Termdebug<space>
let g:termdebug_wide=1
nnoremap <F6> :Break<cr>
nnoremap <F7> :Over<cr>
nnoremap <F8> :Step<cr>

" easy to add time
func Time()
	return "update by chenxuan ".strftime("%Y-%m-%d %H:%M:%S")
endfunc

" term console
func! Tapi_EditFile(bufnum,arglist)
	execute ":wincmd p"
	if isdirectory(a:arglist[0])
		execute ":cd " . a:arglist[0]|echo "cd ".a:arglist[0]." success"
	else
		execute ":edit " . a:arglist[0]|echo "open ".a:arglist[0]." success"
	endif
	if len(a:arglist)>1|call term_sendkeys(a:bufnum,a:arglist[1]."\<cr>")|endif
	if len(gettabinfo())>1|tabclose|if filereadable(a:arglist[0])|execute ":edit " . a:arglist[0]|endif|endif
endfunc
tnoremap <c-\> <c-\><c-n>
tnoremap <c-o> printf '\033]51;["call","Tapi_EditFile",["%s/%s"]]\007' $PWD<space>
tnoremap <c-]> printf '\033]51;["call","Tapi_EditFile",["%s/%s","exit"]]\007' $PWD<space>
tnoremap <c-z> exit<cr>
nnoremap <leader><leader>T :bo term ++rows=<c-r>=winheight(0)/3<cr><cr>
nnoremap <leader><leader>t :vert term<CR>
nnoremap <silent><space><space>t :tabe<cr>:execute ":vert term ++curwin ++close " <cr>
nnoremap <silent><space><space>T :let @s=expand('%:p:h')<cr>:tabe<cr>:call term_start("bash",{"cwd":"<c-r>=@s<cr>","curwin":1,"term_finish":"close"})<cr>
tnoremap <c-w>l <c-\><c-n><c-w>l
tnoremap <c-w>h <c-\><c-n><c-w>h
tnoremap <c-w>j <c-\><c-n><c-w>j
tnoremap <c-w>k <c-\><c-n><c-w>k
if has('nvim')
	tnoremap <c-o> ~/.config/nvim/nvr.py -l <space>
	tnoremap <c-]> ~/.config/nvim/nvr.py -l<space>;exit<left><left><left><left><left>
	nnoremap <leader><leader>T :split<CR>:term<cr>
	nnoremap <leader><leader>t :vsplit<CR>:term<cr>
	nnoremap <silent><space><space>t :term<cr>
	nnoremap <silent><space><space>T :let @s=expand('%:p:h')<cr>:enew<cr>:call termopen('bash',{'cwd':'<c-r>=@s<cr>'})<cr>
endif

" lazygit
if !has('nvim')
	nnoremap <silent><space>g :call <sid>ShellOpenFile("LAZYGIT_FILE")<cr>:call term_start("lazygit",{"close_cb":"<sid>ShellOpenFile","curwin":1,"term_finish":"close"})<cr>
else
	nnoremap <silent><space>g :call <sid>ShellOpenFile("LAZYGIT_FILE")<cr>:enew<cr>:call termopen("lazygit")<cr>
endif
nnoremap <silent><space>G :let @s=expand('%')<cr>:tabe<cr>:vert term ++curwin ++close lazygit -f <c-r>s<cr>
func! s:ShellOpenFile(event) abort
	if type(a:event)==type("")
		tabe
		if !exists("s:shell_open_file")||getenv(a:event)==v:null
			let s:shell_open_file=tempname()|let s:shell_open_env=a:event
			call setenv(a:event,s:shell_open_file)
		endif
		return
	endif
	tabclose
	if exists("s:shell_open_file")&&filereadable(expand(s:shell_open_file))&&getenv(s:shell_open_env)==s:shell_open_file&&filereadable(expand(s:shell_open_file))
		call setenv(s:shell_open_env, v:null)
		for line in readfile(s:shell_open_file)
			let msg=split(line)
			let file=msg[0]
			if filereadable(file)
				execute ":edit ".file
			elseif isdirectory(file)
				execute ":cd ".file
			endif
			if len(msg)>1&&msg[1]!=1|call cursor(msg[1],0)|endif
		endfor
	endif
endfunc

" fzf self defile
func! s:FzfFind(command)
	if !has('nvim')
		call term_start('bash',{'term_finish':"close",'vertical': v:true})
		call term_sendkeys(term_list()[0],a:command."\<cr>")
	else
		vsplit
		enew
		let chanid=termopen('bash')
		call chansend(chanid, a:command."\<cr>")
	endif
endfunc
func! s:FzfFindTab(command)
	if !has('nvim')
		tabe
		call term_start('bash',{'term_finish':"close",'curwin':1})
		call term_sendkeys(term_list()[0],a:command."\<cr>")
	else
		enew
		let chanid=termopen('bash')
		call chansend(chanid, a:command."\<cr>")
	endif
endfunc
let g:fzf_temp_file=""
func! Tapi_Fzf(bufnum,arglist)
	wincmd p|let temp=getenv("FZF_VIM")
	if len(a:arglist)>1&&!has('nvim')|call term_sendkeys(a:bufnum,a:arglist[len(a:arglist)-1]."\<cr>")|endif
	if temp!=v:null
		for line in readfile(g:fzf_temp_file)
			let list=matchstr(line,"\/\^.*")
			if a:arglist[0]=="0"
				let @/="\\V\\^".line."\\$"
				call feedkeys('n','in')|set hlsearch
			elseif a:arglist[0]=="1"
				let list= matchlist(line,'\([^:]\+\):\(\d\+\):\(\d\+\):')
				if len(list)<4|echom line." cannot found"|return|endif
				exec ":edit ".list[1]
				if len(gettabinfo())>1|tabclose|endif
				exec ":edit ".list[1]
				call cursor(list[2], list[3])
			else
				let @/="\\V".escape(strpart(list,1,len(list)-2),"^$")
				call feedkeys('n','in')|set hlsearch
			endif
		endfor
	endif
endfunc

" lf config define
nnoremap <silent><space>E :call <sid>ShellOpenFile("OPEN_FILE")<cr>:call term_start("lf <c-r>=getenv('HOME')<cr>",{"close_cb":"<sid>ShellOpenFile","curwin":1})<cr>
nnoremap <silent><space>e :call <sid>ShellOpenFile("OPEN_FILE")<cr>:call term_start("lf",{"close_cb":"<sid>ShellOpenFile","curwin":1})<cr>

" set pair baket
inoremap ( ()<left>
inoremap [ []<left>
inoremap { {}<left>
cnoremap <expr>(    getcmdtype()==':' ? "()\<left>" : "("
cnoremap <expr>[    getcmdtype()==':' ? "[]\<left>" : "["
cnoremap <expr>{    getcmdtype()==':' ? "{}\<left>" : "{"

" jump
func! s:Judge(ch,mode)
	if a:mode=='c'&&getcmdtype()!=':'|return a:ch|endif
	if a:mode!='c'
		let ch=getline('.')[col('.')-1]
	else
		let ch=getcmdline()[getcmdpos()-1]
	endif
	if a:ch=='"'||a:ch=="'"||a:ch=='`'
		if ch!=a:ch
			return a:ch.a:ch."\<left>"
		endif
	endif
	if ch==a:ch
		return "\<right>"
	endif
	return a:ch
endfunc
inoremap <expr><silent>" <sid>Judge('"','i')
inoremap <expr><silent>` <sid>Judge('`','i')
inoremap <expr><silent>' <sid>Judge("'",'i')
inoremap <expr><silent>> <sid>Judge('>','i')
inoremap <expr><silent>) <sid>Judge(')','i')
inoremap <expr><silent>} <sid>Judge('}','i')
inoremap <expr><silent>] <sid>Judge(']','i')
cnoremap <expr>" <sid>Judge('"','c')
cnoremap <expr>` <sid>Judge('`','c')
cnoremap <expr>' <sid>Judge("'",'c')
cnoremap <expr>> <sid>Judge('>','c')
cnoremap <expr>) <sid>Judge(')','c')
cnoremap <expr>} <sid>Judge('}','c')
cnoremap <expr>] <sid>Judge(']','c')
" set backspace
inoremap <expr><bs> <sid>Backspace('i')
cnoremap <expr><bs> <sid>Backspace('c')
func! s:Backspace(mode)
	if a:mode!='c'
		let s:pair=getline('.')[col('.')-1]|let s:pair_l=getline('.')[col('.')-2]
	else
		let s:pair=getcmdline()[getcmdpos()-1]|let s:pair_l=getcmdline()[getcmdpos()-2]
	endif
	if has_key(g:pair_map, s:pair_l)&&(g:pair_map[s:pair_l]==s:pair)
		return "\<right>\<bs>\<bs>"
	else
		return "\<bs>"
	endif
endfunc

" yank and paste
nnoremap <leader>p "0p
vnoremap <leader>p "0p
nnoremap <leader>P "0P
vnoremap <leader>P "0P

" vimdiff tool
" cab <expr>Diff "Diff ".expand('%:p:h')."/"
" command! -nargs=1 -bang -complete=file Diff exec ":vert diffsplit ".<q-args>
" command! -nargs=0 Remote :diffg RE
" command! -nargs=0 Base   :diffg BA
" command! -nargs=0 Local  :diffg LO

" edit binrary
" func! s:BinraryEdit(args) abort
	" if join(readfile(expand('%:p'), 'b', 5), '\n') !~# '[\x00-\x08\x10-\x1a\x1c-\x1f]\{2,}'
		" echo "not a bin file"|return
	" endif
	" if &readonly|execute ":edit ++bin ".expand('%:p')|endif|setlocal bin
	" setlocal bin
	" if !executable('xxd')|echoerr "xxd not find,install it first"|return|endif
	" echo "transform...please wait..."
	" let g:xxd_cmd=":%!xxd ".a:args
	" silent! execute g:xxd_cmd|let &modified=0|redraw!
	" augroup Binrary
		" au!
		" autocmd BufWritePre  <buffer> let g:bin_pos_now=getcurpos()|silent! exec ":%!xxd -r"
		" autocmd BufWritePost <buffer> silent! exec g:xxd_cmd|call cursor([g:bin_pos_now[1],g:bin_pos_now[2]])
		" autocmd BufDelete    <buffer> au! Binrary
	" augroup END
" endfunc
" command! -nargs=? Binrary :call <sid>BinraryEdit(<q-args>)

" change window width
nnoremap <c-up> <c-w>+
nnoremap <c-down> <c-w>-
nnoremap <c-left> <c-w><
nnoremap <c-right> <c-w>>

" change window in normal
" nnoremap <c-k> <c-w>k
" nnoremap <c-j> <c-w>j
" nnoremap <c-h> <c-w>h
" nnoremap <c-l> <c-w>l
nnoremap <s-up>    <c-w>k
nnoremap <s-down>  <c-w>j
nnoremap <s-left>  <c-w>h
nnoremap <s-right> <c-w>l

" change window location
nnoremap <c-s-up> <c-w>K
nnoremap <c-s-down> <c-w>J
nnoremap <c-s-left> <c-w>H
nnoremap <c-s-right> <c-w>L

" quick fix
nnoremap [q :cnext<cr>
nnoremap ]q :cprevious<cr>
nnoremap \q :cclose<cr>
nnoremap =q :copen<cr>
nnoremap ]Q :cnext<cr>:call <sid>Qfpopup()<cr>
nnoremap [Q :cprevious<cr>:call <sid>Qfpopup()<cr>
func! s:Qfpopup()abort
	let dict=getqflist({'all':1})|let pos=dict['idx']|let item=dict['items']|let len=len(dict['items'])
	if len==0||(pos==1&&item[pos-1]['lnum']==0)|cclose|return|endif|let show=[item[pos-1]['text']]
	while pos<len&&item[pos]['lnum']==0|let show=add(show,item[pos]['text'])|let pos+=1|endwhile
	let show=show[0:-2]|call popup_atcursor(show,{})
endfunc

" set mouse
func! MouseConfig()
	set mouse=a
	set mousemodel=popup_setpos
	" visual model
	vnoremenu PopUp.Yank\ Text "+y
	vnoremenu PopUp.Cut\ Text "+d
	vnoremenu PopUp.Del\ Text "_d
	vnoremenu PopUp.Paste\ Text "+p
	vnoremenu PopUp.-Sep- :<cr>
	" normal model
	nnoremenu PopUp.Paste\ Text "+p
	nnoremenu PopUp.Select\ All ggVG
	nnoremenu PopUp.Back\ Pos <c-o>zz
	nnoremenu PopUp.Next\ Pos <c-i>zz
	" fold
	nnoremenu PopUp.Open\ Fold  zO
	nnoremenu PopUp.Close\ Fold zC
	" close
	nnoremenu PopUp.Close\ Mouse :set mouse=""<cr>
	nnoremenu PopUp.-Sep- :<cr>
	" term model
	tlnoremenu PopUp.Exit\ Term exit<cr>
endfunc
unmenu PopUp
call MouseConfig() " default set mouse enable
nnoremap <silent><nowait>=m :unmenu PopUp<cr>call MouseConfig()<cr>
nnoremap <silent><nowait>\m :set mouse=""<cr>

" global popupmenu
let g:rightmouse_popupmenu={}
let g:rightmouse_extramenu=[]
func AddMouseMenu(func)
	if type(a:func)!=2|echoerr 'func must be function'|return|endif
	call add(g:rightmouse_extramenu,a:func)
endfunc
func RightMouseMenu()
	if has_key(g:rightmouse_popupmenu, &ft)|call g:rightmouse_popupmenu[&ft]()
	else|call MouseConfig()|endif
	if !empty(g:rightmouse_extramenu)|for Func_name in g:rightmouse_extramenu|call Func_name()|endfor|endif
endfunc

" show indent line
nnoremap <silent><nowait>=i :set list lcs=tab:¦\<space> <cr>
nnoremap <silent><nowait>\i :set nolist<cr>

" set spell
nnoremap <silent><nowait>=s :setlocal spell<cr>
nnoremap <silent><nowait>\s :setlocal nospell<cr>
" z= is list of change

" set wrap
nnoremap <silent><nowait>=r :setlocal wrap<cr>:noremap<buffer> j gj<cr>:noremap<buffer> k gk<cr>
nnoremap <silent><nowait>\r :setlocal nowrap<cr>:unmap<buffer> j<cr>:unmap<buffer> k<cr>

" set line number
nnoremap <silent><nowait>=n :setlocal norelativenumber<cr>
nnoremap <silent><nowait>\n :setlocal relativenumber<bar>setlocal number<cr>

" close/open number
nnoremap <silent><nowait>=N :setlocal norelativenumber<cr>:setlocal nonumber<cr>:set nolist<cr>
nnoremap <silent><nowait>\N :setlocal relativenumber<cr>:setlocal number<cr>:set list lcs=tab:¦\<space> <cr>

" set fold auto,use zE unset all fold,zf create fold
nnoremap <silent><nowait>=z :setlocal fdm=indent<cr>:setlocal fen<cr>
nnoremap <silent><nowait>\z :setlocal fdm=manual<cr>:setlocal nofen<cr>
nnoremap <silent><nowait>=o zO
nnoremap <silent><nowait>\o zC
nnoremap <silent><nowait><expr><bs> foldlevel('.')>0?"zc":"\<bs>"

" tab ctrl
nnoremap <silent><nowait>=t :tabnew<cr>
nnoremap <silent><nowait>\t :tabc<cr>
nnoremap <silent><nowait>[t :tabp<cr>
nnoremap <silent><nowait>]t :tabn<cr>

" set search noh
nnoremap <silent><nowait>\h :noh<cr>
nnoremap <silent><nowait>=h :set hlsearch<cr>

" set auto indent file
nnoremap <silent>=<tab> :call <sid>IndentSet()<cr>
func! s:IndentSet()abort
	let line=matchstr(getline(line('.')),"^\\s*")
	for temp in getline(line('.')+1, line('$'))
		let temp=matchstr(temp,"^\\s*")|if temp!=line|break|endif
	endfor
	if (len(line)!=0&&line[0]==' ')||(len(temp)!=0&&temp[0]==' ')
		setlocal expandtab|exec "setlocal shiftwidth=".abs(len(line)-len(temp))
	endif
	echo 'indent ok'
endfunc
func! g:SetTypeIndex(index_type,index_num) abort
	if a:index_type=='tab'|setlocal noexpandtab
	else|setlocal expandtab|endif
	exec "setlocal shiftwidth=".a:index_num
	exec "setlocal softtabstop=".a:index_num
	exec "setlocal softtabstop=".a:index_num
endfunc

" delete <space> in end of line
nnoremap <silent><nowait>d<space> :%s/ *$//g<cr>:noh<cr><c-o>
nnoremap <nowait>g<space> :syntax match DiffDelete " *$"<cr>

" delete empty line
nnoremap <silent><nowait>dl :g/^\s*$/d<cr>

" select search
xmap g/ "sy/\V<c-r>=@s<cr>

" run macro in visual model
xnoremap @ :normal @

" repeat for macro
nnoremap <silent><c-q> @@

" use select area to replace
xnoremap s  :<c-u>execute "normal! gv\"sy"<cr>:%s/\V<c-r>=escape(@s,'/\.')<cr>/<c-r>=escape(@s,'/\.')<cr>/gn<left><left><left>
nnoremap gs :%s/<c-r>=@/<cr>//gn<left><left><left>
xnoremap gs :<c-u>execute "normal! gv\"sy"<cr>:call <sid>ReplaceGlobal(@s)<cr>
func s:ReplaceGlobal(str) abort
	let escape_char='."'
	let str=escape(a:str,escape_char)|let replace=escape(input("replace ".a:str." to:",a:str),escape_char)
	if replace==""|return|endif
	let sed='sed'|if has('macunix')|let sed='gsed'|endif
	echo system('find . -path "./.git" -prune -o -type f -exec '.sed.' -i "s|'.str.'|'.replace.'|g" {} +')
	" reload file
	exec ":edit ".expand('%')
endfunc

" indent buffer
nnoremap <silent><nowait> =e gg=G
onoremap <silent>ae :<c-u>normal! ggVG<cr>
xnoremap <silent>ae :<c-u>normal! ggVG<cr>

" object line
onoremap <silent>il :<c-u>normal! ^v$BE<cr>
xnoremap <silent>il :<c-u>normal! ^v$<cr><left>
onoremap <silent>al :<c-u>normal! 0v$<cr>
xnoremap <silent>al :<c-u>normal! 0v$<cr>

" session manager
" object argc
onoremap <silent>aa :<c-u>call <sid>GetArgs('a')<cr>
onoremap <silent>ia :<c-u>call <sid>GetArgs('i')<cr>
xnoremap <silent>aa :<c-u>call <sid>GetArgs('a')<cr>
xnoremap <silent>ia :<c-u>call <sid>GetArgs('i')<cr>
" set split window
" nnoremap <silent><nowait>_ :vsp<cr>:bn<cr>
" nnoremap <silent><nowait>+ :sp<cr>:bn<cr>
" set split window
nnoremap <leader>v :vsp<cr>:bn<cr>
nnoremap <leader>s :sp<cr>:bn<cr>
func! s:GetArgs(model)
	let model=a:model
	let line=line('.')|let col=col('.')|let i=col-1|let now=getline('.')
	let begin=-1|let end=-1|let pos0=-1|let pos1=-1
	let buket=0|let flag=0
	while i>0
		let temp=now[i]|let flag=0
		if temp==')'|let buket+=1|endif
		if temp=='('|let buket-=1|let flag=1|endif
		if (buket>0)||(buket==0&&flag)|let i-=1|continue|endif
		if temp=='('|| temp==','|let begin=temp|let pos0=i|break|endif
		let i-=1
	endwhile
	let i=col|let buket=0|let flag=0
	while i<col('$')
		let temp=now[i]|let flag=0
		if temp=='('|let buket+=1|endif
		if temp==')'|let buket-=1|let flag=1|endif
		if (buket>0)||(buket==0&&flag)|let i+=1|continue|endif
		if temp==')'|| temp==','|let end=temp|let pos1=i|break|endif
		let i+=1
	endwhile
	if model=='i'
		let pos0+=1|let pos1-=1
	else
		if begin=='('|let pos0+=1|else|let pos1-=1|endif
	endif
	call cursor([line,pos0+1])
	let pos1-=pos0|echom end
	execute "normal! v".pos1."l"
endfunc

" easy to get obj
onoremap <silent>i, i'
onoremap <silent>a, a'
xnoremap <silent>i, i'
xnoremap <silent>a, a'
onoremap <silent>i; i"
onoremap <silent>a; a"
xnoremap <silent>i; i"
xnoremap <silent>a; a"
onoremap <silent>in i{
onoremap <silent>an a{
xnoremap <silent>in i{
xnoremap <silent>an a{

nnoremap <space>S :mksession! .session.vim<cr>
nnoremap <space>s :silent! source .session.vim<cr>
xnoremap <tab>   >gv
xnoremap <s-tab> <gv
" Clear search highlights
nmap <silent> <Esc><Esc> :noh<CR>
" Close buffer without affecting splits
nmap <leader>d :bprevious<CR>:bdelete #<CR>
" Easy buffer navigation
nmap <leader>bn :bn<CR>
nmap <leader>bp :bp<CR>
nmap <leader>b :buffer <Tab>
" languages setting
augroup languages
	au!
	autocmd! BufWritePost * call LanguageModeSet()
	autocmd BufNewFile * call LanguagePreCode()
augroup END
nnoremap <silent><space>xx :call LanguageRun()<cr>
let g:language_config={
			\"sh":{"run":"sh","code":"#!/bin/bash","mode":"rwxrwxr-x" },
			\"python":{"run":"python3","code":"#!/usr/bin/env python3","mode":"rwxrwxr-x" }
			\}

func LanguagePreCode()
	let ft=&ft
	if !has_key(g:language_config,ft)|return|endif
	let config=g:language_config[ft]|let path=expand('%')
	let code=config["code"]
	if code==""|return|endif
	call append(line(".")-1,code)
endfunc

function LanguageModeSet()
	let ft=&ft
	if !has_key(g:language_config,ft)|return|endif
	let config=g:language_config[ft]|let path=expand('%')
	let mode=config["mode"]
	if mode==""|return|endif
	if !filereadable(path)|write|endif
	call setfperm(path,mode)
endfunction

function LanguageRun()
	let ft=&ft
	if !has_key(g:language_config,ft)|return|endif
	let config=g:language_config[ft]|let path=expand('%')
	if !filereadable(path)|write|endif
	let run=config["run"]
	if has('nvim')|let g:nvim_term_open=1|exec "vert term ".run." ".path|endif
	exec "vert term ".run." ".path
endfunction


" set statusline {{{
function! GetMode()
	let m = mode()|let s:str=''|let s:color='#9ECE6A'
	if m == 'R'|let s:color='#F7768E'|let s:str= 'REPLACE '
	elseif m == 'v'|let s:color='#F7768E'|let s:str= 'VISUAL '
	elseif m == 'i'|let s:color='#7AA2F7'|let s:str= 'INSERT '
	elseif m == 't'|let s:color='#7AA2F7'|let s:str= 'TERMINAL '
	else|let s:color='#9ECE6A'|let s:str= 'NORMAL '
	endif
	exec 'highlight User3 font=#000000 guifg=#1a1b26 guibg='.s:color
	exec 'highlight User4 font=#000000 guifg='.s:color.' guibg=#232433'
	redraw|return s:str
endfunction

let g:status_git_branch=""
if has('nvim')
	let g:status_git_branch=' nvim'.' |'
endif
func! GitBranchShow(chan,msg)
	let g:status_git_branch=" ".a:msg." |"
endfunc
if g:status_git_branch==""
	call job_start("git rev-parse --abbrev-ref HEAD",{"out_cb":"GitBranchShow"})
endif

set statusline=%3*\ %{GetMode()}
set statusline+=%4*\ %{g:status_git_branch}\ %F\ \|%m%r%h%w%=
set statusline+=%3*\ %Y\ |
set statusline+=%3*¦%{\"\".(\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\"+\":\"\").\"\"}¦
set statusline+=%5*\ %l/%-L¦%3p%%¦:%v\ ¦
"}}}

" highlight define,you can change self {{{
highlight User1 font=#000000 guifg=#1a1b26 guibg=#9ECE6A
highlight User2 font=#000000 guifg=#9ECE6A guibg=#232433
highlight User3 font=#000000 guifg=#1a1b26 guibg=#9ECE6A
highlight User4 font=#000000 guifg=#9ECE6A guibg=#232433
highlight User5 font=#000000 guifg=#1a1b26 guibg=#7AA2F7
highlight User6 font=#000000 guifg=#7AA2F7 guibg=#232433
"}}}

" set netrw {{{
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 15
set fillchars=vert:\⎜
nnoremap <leader>e :Lexplore<cr> " set netrw
highlight VertSplit guibg=#1a1b26 guifg=#232433
"}}}

" slash {{{
func! s:SlashCb()
	if g:slash_able
		set nohlsearch|autocmd! slash
	else
		set hlsearch|let g:slash_able=1
	endif
endf
func! s:Slash(oper)
	augroup slash
		autocmd!
		autocmd CursorMoved,CursorMovedI * call <sid>SlashCb()
	augroup END
	let g:slash_able=0
	return a:oper."zz"
endf
nnoremap <silent><expr>n <sid>Slash('n')
nnoremap <silent><expr>N <sid>Slash('N')
xnoremap <silent>* "sy:let @/="\\V".@s<cr>:set hlsearch<cr>
xnoremap <silent># "sy:let @/="\\V".@s<cr>:let v:searchforward=0<cr>:set hlsearch<cr>
nnoremap <silent>* :let @/="\\<".expand('<cword>')."\\>"<cr>:set hlsearch<cr>
nnoremap <silent># :let @/="\\<".expand('<cword>')."\\>"<cr>:let v:searchforward=0<cr>:set hlsearch<cr>
xnoremap <silent>g8 "sy:let @/="\\V".@s<cr>:set hlsearch<cr>
nnoremap <silent>g8 :let @/="\\<".expand('<cword>')."\\>"<cr>:set hlsearch<cr>
"}}}

" set tabline {{{
let s:tab_after=""
func! TabLine(direct)
	let s:tab_result=""|let flag=0
	if a:direct|return s:tab_after!=""?s:tab_after."|":"\ "|else|let s:tab_after=""|endif
	for buf in getbufinfo({'buflisted':1})
		let s:name=buf.name
		if strridx(buf.name,"/")!=-1|let s:name=strpart(buf.name,strridx(buf.name,"/")+1)|endif
		if buf.name!=expand('%:p')
			let bt=getbufvar(buf.bufnr,"&buftype")
			if bt!=""|continue|endif
			if flag==0|let s:tab_result=s:tab_result."\ ".s:name."\ "|else|let s:tab_after=s:tab_after."\ ".s:name."\ "|endif
		else|let flag=1|endif
	endfor
	redrawt
	return s:tab_result
endfunc
func! TabLineSet()
	if len(gettabinfo())>1|return "%5* Tab %2*%=%1* buffer"|endif
	if &modified|let tab="%2* %0.32(%{TabLine(0)}%)%5*\ %t\ %6*%2*%<%{TabLine(1)}%r%h%w%=%6*\ %5* buffer"
	else|let tab="%2* %0.32(%{TabLine(0)}%)%1*\ %t\ %2*%2*%<%{TabLine(1)}%r%h%w%=%2*\ %1* buffer"
	endif
	return tab
endfunc
set tabline=%!TabLineSet()
set showtabline=2
"}}}

" set gcc enable {{{
func! s:Commentary(line) abort
	let s:num=a:line
	let line=getline(s:num)
	let uncomment=2
	let [l, r] = split( substitute(substitute(substitute(
				\ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', ''), '%s', 1)
	let line = matchstr(getline(s:num),'\S.*\s\@<!')
	if l[-1:] ==# ' ' && stridx(line,l) == -1 && stridx(line,l[0:-2]) == 0|let l = l[:-2]|endif
	if r[0] ==# ' ' && line[-strlen(r):] != r && line[1-strlen(r):] == r[1:]|let r = r[1:]|endif
	if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)|let uncomment = 0|endif
	let line=getline(s:num)
	let [l, r] = split( substitute(substitute(substitute(
				\ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', ''), '%s', 1)
	if strlen(r) > 2 && l.r !~# '\\'
		let line = substitute(line,
					\'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),
					\'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
	endif
	if uncomment
		let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
	else
		let line = substitute(line,'^\%('.matchstr(getline(s:num),'^\s*').'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
	endif
	call setline(s:num,line)
endfunc
" visual gcc
func! s:VisualComment() abort
	for temp in range(min([line('.'),line('v')]),max([line('.'),line('v')]))
		call s:Commentary(temp)
	endfor
endfunc
nnoremap <silent><nowait>gcc :call <sid>Commentary(line('.'))<cr>
xnoremap <silent><nowait>gc  :call <sid>VisualComment()<cr>
"}}}

" vim sourround {{{
let g:pair_map={'(':')','[':']','{':'}','"':'"',"'":"'",'<':'>','`':'`',}
func! s:AddSourround()
	let s:ch=nr2char(getchar())|let s:col=col('.')|let pos=getcurpos()
	norm! gv"sy
	let s:str = @s
	for k in keys(g:pair_map)
		if s:ch==k||s:ch==g:pair_map[k]
			execute ":s/^\\(.\\{".(col('.')-1)."\\}\\)".escape(s:str, '~"/\.^$[]*')."/\\1".k.escape(s:str, '~"/\.^$[]*').g:pair_map[k]."/"
			call setpos('.', pos)
			return
		endif
	endfor
	echo s:ch.' unknow pair'
endfunc
func! s:DelSourround()
	let s:ch=nr2char(getchar())
	if getline('.')[col('.')-1]!=s:ch|echo 'not begin with'.s:ch|return|endif
	for k in keys(g:pair_map)
		if s:ch==k
			let pair=g:pair_map[k]|let left_pos=[line('.'),col('.')]|call search(pair)|let right_pos=[line('.'),col('.')]
			if left_pos[0]==right_pos[0]&&right_pos[1]!=left_pos[1]
				let now_line=getline('.')
				let now_line=strpart(now_line,0,left_pos[1]-1).strpart(now_line,left_pos[1],right_pos[1]-left_pos[1]-1).strpart(now_line,right_pos[1])
				call setline(left_pos[0],now_line)
			endif
			call cursor(left_pos[0],left_pos[1])|return
		endif
	endfor
endfunc
func! s:ChangeSourround()
	let s:ch=nr2char(getchar())|let s:two=nr2char(getchar())
	if !has_key(g:pair_map,s:ch)|echo 'no this ch'.s:ch|return|endif
	if !has_key(g:pair_map,s:two)|echo 'no this ch'.s:two|return|endif
	let s:pair_ch=g:pair_map[s:ch]|let s:pair_two=g:pair_map[s:two]
	if s:ch=="'"|exec "normal! r".s:two."f'"."r".s:pair_two|return|endif
	let escape_str='~"\.^$[]*'."'"
	let s:escape_ch=escape(s:ch, escape_str)|let s:escape_two=escape(s:two, escape_str)
	let s:escape_pair_ch=escape(s:pair_ch, escape_str)|let s:escape_pair_two=escape(s:pair_two, escape_str)
	let pos=getcurpos()|let now_line=getline('.')|if now_line[col('.')-1]!=s:ch|echo 'not begin with'.s:ch|return|endif
	let now_line=strpart(now_line,0,col('.')-1).s:two.strpart(now_line,col('.'))
	let [ line , col ] = searchpairpos(s:escape_ch, '', s:escape_pair_ch, 'n')
	call setline(line('.'),now_line)
	let next_line=getline(line)|let next_line=strpart(next_line,0,col-1).s:pair_two.strpart(next_line,col)
	call setline(line,next_line)|call setpos('.',pos)
endfunc
xnoremap <silent>S  :<c-u>call <sid>AddSourround()<cr>
nnoremap <silent>ds :call <sid>DelSourround()<cr>
nnoremap <silent>cs :call <sid>ChangeSourround()<cr>
"}}}

" git config {{{
function! s:GitBlame()
	let original_win = win_getid()|let line_num=line('.')-1|let original_buf_name = expand('%:p')
	call feedkeys("zz")|execute 'vsp blame'|execute 'read !git blame '.original_buf_name|setlocal filetype=gitblame|setlocal bt=nofile
	call feedkeys("ggdd".line_num."jzz:syncbind\<cr>")|call setwinvar(original_win,"&scb",1)|set scb
	autocmd BufDelete <buffer> set noscb
endfunction
function s:GitDiff(cmd) abort
	exec "vsp ".a:cmd
	execute 'read !git '.a:cmd|setlocal filetype=diff|setlocal bt=nofile
endfunction
function! s:GitCommand(cmd) abort
	if stridx(a:cmd,"blame")==0
		call s:GitBlame()
	elseif stridx(a:cmd,"diff")==0
		call s:GitDiff(a:cmd)
	else
		echo system("git ".a:cmd)
	endif
endfunction
nnoremap <leader>g :!git log --all --decorate --oneline --graph<cr>
nnoremap <silent><nowait>gb :Git blame<cr>
command! -nargs=+ Git call s:GitCommand(<q-args>)

" make run
command! -nargs=+ Run let command=strpart(<q-args>,0,stridx(<q-args>,' '))|
			\exec "set makeprg=".command|
			\exec ":make ".strpart(<q-args>,stridx(<q-args>,' '))|
			\call <sid>Qfpopup()
nnoremap <space>: :Run<space>
vnoremap <space>: "sy:<c-u>Run<space><c-r>=@s<cr>
cab pyj !python3 -m json.tool
"}}}

" tagbar {{{
let g:tagbar_name="tagbar"
let g:tagbar_arr=[]
let g:tagbar_current_win_id=0
let g:tagbar_win_id=0
func s:EnterFotTagBar()
	let current_buf_name = expand('%:t')|let line=line('.')|let origin=g:tagbar_arr[line][1]|let @/="\\V".escape(strpart(origin,1,len(origin)-2),"^$")
	call win_gotoid(g:tagbar_current_win_id)|call feedkeys('n','in')|set hlsearch
endfunc
func s:TagBar(is_update)
	if g:tagbar_win_id!=0&&a:is_update==0
		call win_gotoid(g:tagbar_win_id)|bdelete
		let g:tagbar_win_id=0|let g:tagbar_arr=[]|let g:tagbar_current_win_id=0
		return
	endif
	if a:is_update
		if win_getid()==g:tagbar_win_id|return|endif
		if win_getid()==g:tagbar_current_win_id|return|endif
		if getbufvar(bufnr('%'), '&buftype')!=""|return|endif
		if getbufvar(bufnr('%'), '&filetype')=="netrw"|return|endif
		if getbufvar(bufnr('%'), '&filetype')=="netrw"|return|endif

		let old=win_getid()
		call win_gotoid(g:tagbar_win_id)|bdelete
		call win_gotoid(old)
	endif

	let tmp_file=tempname()|let file_path=expand('%:p')
	call system('ctags '.'-x --_xformat="%N	%P" --sort=no -f - >'.tmp_file.' '.file_path)|let arr=[]|let g:tagbar_current_win_id=win_getid()|let file=readfile(tmp_file)
	for line in file
		let temp=[split(line,'\t')]
		let list=matchstr(line,"\/\^.*")
		let arr+=[[temp[0][0],list]]
	endfor
	silent! rightbelow vsplit enew|let screen_width = winwidth(0)|let new_width = screen_width /3
	execute 'vertical resize' new_width|execute 'file ' . g:tagbar_name|setlocal winfixwidth
	let g:tagbar_win_id=win_getid()|let i=0
	for map_line in arr|call setline(i,map_line[0])|let i+=1|endfor
	let g:tagbar_arr=arr
	setlocal nomod|setlocal bt=nofile|setlocal ft=tagbar
	nnoremap <buffer><silent><enter> :call <sid>EnterFotTagBar()<cr>
	nnoremap <buffer><2-leftMouse> :call <sid>EnterFotTagBar()<cr>
	augroup TagBar
		autocmd!
		autocmd BufDelete <buffer> au! TagBar
	augroup END
	call win_gotoid(g:tagbar_current_win_id)
endfunc
nnoremap <leader>t :call <sid>TagBar(0)<cr>
" }}}
"
" like easy motion {{{
let s:easymotion_key=['j','l','k','h','a','s','d','f','g','q','w','e','r','u','i','o','p','c','v','b','n','m','t','y','z','x']
let s:easymotion_leader=[';',',',' ',"'",'.','/','[','\',']']|let s:easymotion_leader_dict={';':0,',':0,'.':0,"'":0,' ':0,'/':0,'[':0,'\':0,']':0}
func! s:EasyMotion()abort
	echo "input key:"|let ch=nr2char(getchar())|let s:easymotion={}|let llen=len(s:easymotion_leader)+1
	let ch=tolower(ch)|if ch>='a'&&ch<='z'|let up=toupper(ch)|else|let up=""|endif
	let info=winsaveview()|let info["endline"]=winheight(0)+info["topline"]|let width=winwidth(0)|let num=0|let old=ch|let pos=0|let klen=len(s:easymotion_key)
	if ch=="\<c-[>"|return|endif|if &fen|setlocal nofen|endif
	let lines=getbufline("%",info["topline"],info["endline"])|let bak=copy(lines)|set nohlsearch
	let hlcomment=[]|let begin=info["topline"]|let end=info["endline"]
	while end-begin>=8|call add(hlcomment,matchaddpos("comment",range(begin,end)))|let begin+=8|endwhile
	call add(hlcomment,matchaddpos("comment",range(begin,end)))
	let listl=range(0,len(lines)-1)|let nowline=info["lnum"]-info["topline"]|call sort(listl,{arg1,arg2 -> abs(arg2-nowline)-abs(arg1-nowline)})
	for i in listl
		" if i+info["topline"]==info["lnum"]|continue|endif
		while 1
			let pos=stridx(lines[i],ch,pos)
			if up!=""|let postemp=stridx(lines[i],up,pos)|if postemp!=-1&&(postemp<pos||pos==-1)|let pos=postemp|endif|endif
			if pos!=-1&&(pos<width||&wrap)
				if num<klen|let req=s:easymotion_key[num]
				elseif num<llen*klen|let req=s:easymotion_leader[num/klen-1].s:easymotion_key[num%klen]
				else|break
				endif
				let m= matchaddpos("incsearch", [[i+info["topline"],pos+1,len(req)]])
				let s:easymotion[req]={"line":i,"pos":pos,"hl":m}
				let lines[i]=strpart(lines[i],0,pos).req.strpart(lines[i],pos+len(req))
				let num+=1|let pos+=2|if num>=llen*klen|break|endif
			else|let pos=0|break
			endif
		endwhile
		if num>=llen*klen|break|endif
	endfor
	if len(s:easymotion)==0|echo "cannot find"|endif
	silent! undojoin|call setline(info["topline"],lines)|redraw!|echo "target key:"| let ch=nr2char(getchar())
	if has_key(s:easymotion_leader_dict,ch)|let ch=ch.nr2char(getchar())|endif
	if has_key(s:easymotion, ch)|let temp=s:easymotion[ch]|call cursor(temp["line"]+info["topline"],temp["pos"]+1)|endif
	for [key,val] in items(s:easymotion)|let i=val["line"]|let pos=val["pos"]|let hl=val["hl"]|call matchdelete(hl)|endfor
	for hlnow in hlcomment|call matchdelete(hlnow)|endfor
	silent! undojoin|call setline(info["topline"],bak)|setlocal nomodified
endfunc
nnoremap <silent>s :call <sid>EasyMotion()<cr>
inoremap <silent><c-s> <c-o>:call <sid>EasyMotion()<cr>
" }}}

" apc.vim {{{ 
let g:apc_enable_ft = get(g:, 'apc_enable_ft', {})    " enable filetypes
let g:apc_enable_tab = get(g:, 'apc_enable_tab', 1)   " remap tab
let g:apc_min_length = get(g:, 'apc_min_length', 2)   " minimal length to open popup
let g:apc_key_ignore = get(g:, 'apc_key_ignore', [])  " ignore keywords
let g:apc_trigger = get(g:, 'apc_trigger', "\<c-n>")  " which key to trigger popmenu

" get word before cursor
function! s:get_context()
	return strpart(getline('.'), 0, col('.') - 1)
endfunc

function! s:meets_keyword(context)
	if g:apc_min_length <= 0
		return 0
	endif
	let matches = matchlist(a:context, '\(\k\{' . g:apc_min_length . ',}\)$')
	if empty(matches)
		return 0
	endif
	for ignore in g:apc_key_ignore
		if stridx(ignore, matches[1]) == 0
			return 0
		endif
	endfor
	return 1
endfunc

function! s:check_back_space() abort
	  return col('.') < 2 || getline('.')[col('.') - 2]  =~# '\s'
endfunc

function! s:on_backspace()
	if pumvisible() == 0
		return "\<BS>"
	endif
	let text = matchstr(s:get_context(), '.*\ze.')
	return s:meets_keyword(text)? "\<BS>" : "\<c-e>\<bs>"
endfunc


" autocmd for CursorMovedI
function! s:feed_popup()
	let enable = get(b:, 'apc_enable', 0)
	let lastx = get(b:, 'apc_lastx', -1)
	let lasty = get(b:, 'apc_lasty', -1)
	let tick = get(b:, 'apc_tick', -1)
	if &bt != '' || enable == 0 || &paste
		return -1
	endif
	let x = col('.') - 1
	let y = line('.') - 1
	if pumvisible()
		let context = s:get_context()
		if s:meets_keyword(context) == 0
			call feedkeys("\<c-e>", 'n')
		endif
		let b:apc_lastx = x
		let b:apc_lasty = y
		let b:apc_tick = b:changedtick
		return 0
	elseif lastx == x && lasty == y
		return -2
	elseif b:changedtick == tick
		let lastx = x
		let lasty = y
		return -3
	endif
	let context = s:get_context()
	if s:meets_keyword(context)
		silent! call feedkeys(get(b:, 'apc_trigger', g:apc_trigger), 'n')
		let b:apc_lastx = x
		let b:apc_lasty = y
		let b:apc_tick = b:changedtick
	endif
	return 0
endfunc

" autocmd for CompleteDone
function! s:complete_done()
	let b:apc_lastx = col('.') - 1
	let b:apc_lasty = line('.') - 1
	let b:apc_tick = b:changedtick
endfunc

" enable apc
function! s:apc_enable()
	call s:apc_disable()
	augroup ApcEventGroup
		au!
		au CursorMovedI <buffer> nested call s:feed_popup()
		au CompleteDone <buffer> call s:complete_done()
	augroup END
	let b:apc_init_autocmd = 1
	if g:apc_enable_tab
		inoremap <silent><buffer><expr> <tab>
					\ pumvisible()? "\<c-n>" :
					\ <SID>check_back_space() ? "\<tab>" : 
					\ get(b:, 'apc_trigger', g:apc_trigger)
		inoremap <silent><buffer><expr> <s-tab>
					\ pumvisible()? "\<c-p>" : "\<s-tab>"
		let b:apc_init_tab = 1
	endif
	if get(g:, 'apc_cr_confirm', 0) == 0
		inoremap <silent><buffer><expr> <cr> 
					\ pumvisible()? "\<c-y>" : "\<cr>"
	else
		inoremap <silent><buffer><expr> <cr> 
					\ pumvisible()? "\<c-y>" : "\<cr>"
	endif
	inoremap <silent><buffer><expr> <bs> <SID>on_backspace()
	let b:apc_init_bs = 1
	let b:apc_init_cr = 1
	let b:apc_save_infer = &infercase
	setlocal infercase
	let b:apc_enable = 1
endfunc

" disable apc
function! s:apc_disable()
	if get(b:, 'apc_init_autocmd', 0)
		augroup ApcEventGroup
			au! 
		augroup END
	endif
	if get(b:, 'apc_init_tab', 0)
		silent! iunmap <buffer><expr> <tab>
		silent! iunmap <buffer><expr> <s-tab>
	endif
	if get(b:, 'apc_init_bs', 0)
		silent! iunmap <buffer><expr> <bs>
	endif
	if get(b:, 'apc_init_cr', 0)
		silent! iunmap <buffer><expr> <cr>
	endif
	if get(b:, 'apc_save_infer', '') != ''
		let &l:infercase = b:apc_save_infer
	endif
	let b:apc_init_autocmd = 0
	let b:apc_init_tab = 0
	let b:apc_init_bs = 0
	let b:apc_init_cr = 0
	let b:apc_save_infer = ''
	let b:apc_enable = 0
endfunc

" check if need to be enabled
function! s:apc_check_init()
	if &bt != '' || get(b:, 'apc_enable', 1) == 0
		return
	endif
	if get(g:apc_enable_ft, &ft, 0) != 0
		ApcEnable
	elseif get(g:apc_enable_ft, '*', 0) != 0
		ApcEnable
	elseif get(b:, 'apc_enable', 0)
		ApcEnable
	endif
endfunc

" commands & autocmd
command! -nargs=0 ApcEnable call s:apc_enable()
command! -nargs=0 ApcDisable call s:apc_disable()

augroup ApcInitGroup
	au!
	au FileType * call s:apc_check_init()
	au BufEnter * call s:apc_check_init()
	au TabEnter * call s:apc_check_init()
augroup END

" 让 apc 只在 python 启用（按需）
let g:apc_enable_ft = {'python': 1}

" 告诉 Vim 去哪些字典里找词
autocmd FileType python setlocal dictionary+=~/.config/vim/dict/python.dict
autocmd FileType python setlocal dictionary+=~/.config/vim/dict/pytorch.dict

" 让 <C-n> 也搜索字典（k）
autocmd FileType python setlocal complete+=k

" 想补 torch.nn.Conv2d 这种带点的词，记得把点算作“关键字”
autocmd FileType python setlocal iskeyword+=.
set completeopt=menu,menuone,noselect
" }}}

" tokyonight color inside,donnot change it {{{
set termguicolors
" let g:tokyonight_style = 'night' " available: night, storm
" let s:t_Co = exists('&t_Co') && !empty(&t_Co) && &t_Co > 1 ? &t_Co : 2
" let s:tmux = executable('tmux') && $TMUX !=# ''
" let g:colors_name = 'tokyonight'|let s:configuration = {}
" let s:configuration.style = get(g:, 'tokyonight_style', 'night')
" let s:configuration.transparent_background = get(g:, 'tokyonight_transparent_background', 0)
" let s:configuration.menu_selection_background = get(g:, 'tokyonight_menu_selection_background', 'green')
" let s:configuration.disable_italic_comment = get(g:, 'tokyonight_disable_italic_comment', 0)
" let s:configuration.enable_italic = get(g:, 'tokyonight_enable_italic', 0)
" let s:configuration.cursor = get(g:, 'tokyonight_cursor', 'auto')
" let s:configuration.current_word = get(g:, 'tokyonight_current_word', get(g:, 'tokyonight_transparent_background', 0) == 0 ? 'grey background' : 'bold')
" if s:configuration.style ==# 'night'
" 	let s:palette = {
" 				\ 'black':      ['#06080a',   '237',  'DarkGrey'],
" 				\ 'bg0':        ['#1a1b26',   '235',  'Black'],
" 				\ 'bg1':        ['#232433',   '236',  'DarkGrey'],
" 				\ 'bg2':        ['#2a2b3d',   '236',  'DarkGrey'],
" 				\ 'bg3':        ['#32344a',   '237',  'DarkGrey'],
" 				\ 'bg4':        ['#3b3d57',   '237',  'Grey'],
" 				\ 'bg_red':     ['#ff7a93',   '203',  'Red'],
" 				\ 'diff_red':   ['#803d49',   '52',   'DarkRed'],
" 				\ 'bg_green':   ['#b9f27c',   '107',  'Green'],
" 				\ 'diff_green': ['#618041',   '22',   'DarkGreen'],
" 				\ 'bg_blue':    ['#7da6ff',   '110',  'Blue'],
" 				\ 'diff_blue':  ['#3e5380',   '17',   'DarkBlue'],
" 				\ 'fg':         ['#a9b1d6',   '250',  'White'],
" 				\ 'red':        ['#F7768E',   '203',  'Red'],
" 				\ 'orange':     ['#FF9E64',   '215',  'Orange'],
" 				\ 'yellow':     ['#E0AF68',   '179',  'Yellow'],
" 				\ 'green':      ['#9ECE6A',   '107',  'Green'],
" 				\ 'blue':       ['#7AA2F7',   '110',  'Blue'],
" 				\ 'purple':     ['#ad8ee6',   '176',  'Magenta'],
" 				\ 'grey':       ['#444B6A',   '246',  'LightGrey'],
" 				\ 'none':       ['NONE',      'NONE', 'NONE']
" 				\ }
" elseif s:configuration.style ==# 'storm'
" 	let s:palette = {
" 				\ 'black':      ['#06080a',   '237',  'DarkGrey'],
" 				\ 'bg0':        ['#24283b',   '235',  'Black'],
" 				\ 'bg1':        ['#282d42',   '236',  'DarkGrey'],
" 				\ 'bg2':        ['#2f344d',   '236',  'DarkGrey'],
" 				\ 'bg3':        ['#333954',   '237',  'DarkGrey'],
" 				\ 'bg4':        ['#3a405e',   '237',  'Grey'],
" 				\ 'bg_red':     ['#ff7a93',   '203',  'Red'],
" 				\ 'diff_red':   ['#803d49',   '52',   'DarkRed'],
" 				\ 'bg_green':   ['#b9f27c',   '107',  'Green'],
" 				\ 'diff_green': ['#618041',   '22',   'DarkGreen'],
" 				\ 'bg_blue':    ['#7da6ff',   '110',  'Blue'],
" 				\ 'diff_blue':  ['#3e5380',   '17',   'DarkBlue'],
" 				\ 'fg':         ['#a9b1d6',   '250',  'White'],
" 				\ 'red':        ['#F7768E',   '203',  'Red'],
" 				\ 'orange':     ['#FF9E64',   '215',  'Orange'],
" 				\ 'yellow':     ['#E0AF68',   '179',  'Yellow'],
" 				\ 'green':      ['#9ECE6A',   '107',  'Green'],
" 				\ 'blue':       ['#7AA2F7',   '110',  'Blue'],
" 				\ 'purple':     ['#ad8ee6',   '176',  'Magenta'],
" 				\ 'grey':       ['#444B6A',   '246',  'LightGrey'],
" 				\ 'none':       ['NONE',      'NONE', 'NONE']
" 				\ }
" endif
" if (has('termguicolors') && &termguicolors) || has('gui_running')  " guifg guibg gui cterm guisp
" 	function! s:HL(group, fg, bg, ...)
" 		let hl_string = [ 'highlight', a:group, 'guifg=' . a:fg[0], 'guibg=' . a:bg[0], ]
" 		if a:0 >= 1
" 			if a:1 ==# 'undercurl'
" 				if !s:tmux|call add(hl_string, 'gui=undercurl')
" 				else|call add(hl_string, 'gui=underline')
" 				endif
" 				call add(hl_string, 'cterm=underline')
" 			else|call add(hl_string, 'gui=' . a:1)|call add(hl_string, 'cterm=' . a:1)
" 			endif
" 		else|call add(hl_string, 'gui=NONE')|call add(hl_string, 'cterm=NONE')
" 		endif
" 		if a:0 >= 2|call add(hl_string, 'guisp=' . a:2[0])|endif
" 		execute join(hl_string, ' ')
" 	endfunction
" elseif s:t_Co >= 256
" 	function! s:HL(group, fg, bg, ...)
" 		let hl_string = [ 'highlight', a:group, 'ctermfg=' . a:fg[1], 'ctermbg=' . a:bg[1]]
" 		if a:0 >= 1
" 			if a:1 ==# 'undercurl'|call add(hl_string, 'cterm=underline')
" 			else|call add(hl_string, 'cterm=' . a:1)
" 			endif
" 		else|call add(hl_string, 'cterm=NONE')
" 		endif
" 		execute join(hl_string, ' ')
" 	endfunction
" else  " ctermfg ctermbg cterm
" 	function! s:HL(group, fg, bg, ...)
" 		let hl_string = [ 'highlight', a:group, 'ctermfg=' . a:fg[2], 'ctermbg=' . a:bg[2]]
" 		if a:0 >= 1
" 			if a:1 ==# 'undercurl'|call add(hl_string, 'cterm=underline')
" 			else|call add(hl_string, 'cterm=' . a:1)
" 			endif
" 		else|call add(hl_string, 'cterm=NONE')
" 		endif
" 		execute join(hl_string, ' ')
" 	endfunction
" endif
" if s:configuration.transparent_background
" 	call s:HL('Normal', s:palette.fg, s:palette.none)
" 	call s:HL('Terminal', s:palette.fg, s:palette.none)
" 	call s:HL('EndOfBuffer', s:palette.bg0, s:palette.none)
" 	call s:HL('FoldColumn', s:palette.grey, s:palette.none)
" 	call s:HL('Folded', s:palette.grey, s:palette.none)
" 	call s:HL('SignColumn', s:palette.fg, s:palette.none)
" 	call s:HL('ToolbarLine', s:palette.fg, s:palette.none)
" else
" 	call s:HL('Normal', s:palette.fg, s:palette.bg0)
" 	call s:HL('Terminal', s:palette.fg, s:palette.bg0)
" 	call s:HL('EndOfBuffer', s:palette.bg0, s:palette.bg0)
" 	call s:HL('FoldColumn', s:palette.grey, s:palette.bg1)
" 	call s:HL('Folded', s:palette.grey, s:palette.bg1)
" 	call s:HL('SignColumn', s:palette.fg, s:palette.bg1)
" 	call s:HL('ToolbarLine', s:palette.fg, s:palette.bg2)
" endif
" call s:HL('ColorColumn', s:palette.none, s:palette.bg1)
" call s:HL('Conceal', s:palette.grey, s:palette.none)
" if s:configuration.cursor ==# 'auto'|call s:HL('Cursor', s:palette.none, s:palette.none, 'reverse')
" elseif s:configuration.cursor ==# 'red'|call s:HL('Cursor', s:palette.bg0, s:palette.red)
" elseif s:configuration.cursor ==# 'green'|call s:HL('Cursor', s:palette.bg0, s:palette.green)
" elseif s:configuration.cursor ==# 'blue'|call s:HL('Cursor', s:palette.bg0, s:palette.blue)
" endif
" highlight! link vCursor Cursor
" highlight! link iCursor Cursor
" highlight! link lCursor Cursor
" highlight! link CursorIM Cursor
" call s:HL('CursorColumn', s:palette.none, s:palette.bg1)
" call s:HL('CursorLine', s:palette.none, s:palette.bg1)
" call s:HL('LineNr', s:palette.grey, s:palette.none)
" if &relativenumber == 1 && &cursorline == 0|call s:HL('CursorLineNr', s:palette.fg, s:palette.none)
" else|call s:HL('CursorLineNr', s:palette.fg, s:palette.bg1)
" endif
" call s:HL('DiffAdd', s:palette.none, s:palette.diff_green)
" call s:HL('DiffChange', s:palette.none, s:palette.diff_blue)
" call s:HL('DiffDelete', s:palette.none, s:palette.diff_red)
" call s:HL('DiffText', s:palette.none, s:palette.none, 'reverse')
" call s:HL('Directory', s:palette.green, s:palette.none)
" call s:HL('ErrorMsg', s:palette.red, s:palette.none, 'bold,underline')
" call s:HL('WarningMsg', s:palette.yellow, s:palette.none, 'bold')
" call s:HL('ModeMsg', s:palette.fg, s:palette.none, 'bold')
" call s:HL('MoreMsg', s:palette.blue, s:palette.none, 'bold')
" call s:HL('IncSearch', s:palette.bg0, s:palette.bg_red)
" call s:HL('Search', s:palette.bg0, s:palette.bg_green)
" call s:HL('MatchParen', s:palette.none, s:palette.bg4)
" call s:HL('NonText', s:palette.bg4, s:palette.none)
" call s:HL('Whitespace', s:palette.bg4, s:palette.none)
" call s:HL('SpecialKey', s:palette.bg4, s:palette.none)
" call s:HL('Pmenu', s:palette.fg, s:palette.bg2)
" call s:HL('PmenuSbar', s:palette.none, s:palette.bg2)
" if s:configuration.menu_selection_background ==# 'blue'
" 	call s:HL('PmenuSel', s:palette.bg0, s:palette.bg_blue)
" 	call s:HL('WildMenu', s:palette.bg0, s:palette.bg_blue)
" elseif s:configuration.menu_selection_background ==# 'green'
" 	call s:HL('PmenuSel', s:palette.bg0, s:palette.bg_green)
" 	call s:HL('WildMenu', s:palette.bg0, s:palette.bg_green)
" elseif s:configuration.menu_selection_background ==# 'red'
" 	call s:HL('PmenuSel', s:palette.bg0, s:palette.bg_red)
" 	call s:HL('WildMenu', s:palette.bg0, s:palette.bg_red)
" endif
" call s:HL('PmenuThumb', s:palette.none, s:palette.grey)
" call s:HL('Question', s:palette.yellow, s:palette.none)
" call s:HL('SpellBad', s:palette.red, s:palette.none, 'undercurl', s:palette.red)
" call s:HL('SpellCap', s:palette.yellow, s:palette.none, 'undercurl', s:palette.yellow)
" call s:HL('SpellLocal', s:palette.blue, s:palette.none, 'undercurl', s:palette.blue)
" call s:HL('SpellRare', s:palette.purple, s:palette.none, 'undercurl', s:palette.purple)
" call s:HL('StatusLine', s:palette.fg, s:palette.bg3)
" call s:HL('StatusLineTerm', s:palette.fg, s:palette.bg3)
" call s:HL('StatusLineNC', s:palette.grey, s:palette.bg1)
" call s:HL('StatusLineTermNC', s:palette.grey, s:palette.bg1)
" call s:HL('TabLine', s:palette.fg, s:palette.bg4)
" call s:HL('TabLineFill', s:palette.grey, s:palette.bg1)
" call s:HL('TabLineSel', s:palette.bg0, s:palette.bg_red)
" call s:HL('VertSplit', s:palette.black, s:palette.none)
" call s:HL('Visual', s:palette.none, s:palette.bg3)
" call s:HL('VisualNOS', s:palette.none, s:palette.bg3, 'underline')
" call s:HL('QuickFixLine', s:palette.blue, s:palette.none, 'bold')
" call s:HL('Debug', s:palette.yellow, s:palette.none)
" call s:HL('debugPC', s:palette.bg0, s:palette.green)
" call s:HL('debugBreakpoint', s:palette.bg0, s:palette.red)
" call s:HL('ToolbarButton', s:palette.bg0, s:palette.bg_blue)
" call s:HL('Type', s:palette.blue, s:palette.none, 'italic')
" call s:HL('Structure', s:palette.blue, s:palette.none, 'italic')
" call s:HL('StorageClass', s:palette.blue, s:palette.none, 'italic')
" call s:HL('Identifier', s:palette.orange, s:palette.none, 'italic')
" call s:HL('Constant', s:palette.orange, s:palette.none, 'italic')
" call s:HL('PreProc', s:palette.red, s:palette.none)
" call s:HL('PreCondit', s:palette.red, s:palette.none)
" call s:HL('Include', s:palette.red, s:palette.none)
" call s:HL('Keyword', s:palette.red, s:palette.none)
" call s:HL('Define', s:palette.red, s:palette.none)
" call s:HL('Typedef', s:palette.red, s:palette.none)
" call s:HL('Exception', s:palette.red, s:palette.none)
" call s:HL('Conditional', s:palette.red, s:palette.none)
" call s:HL('Repeat', s:palette.red, s:palette.none)
" call s:HL('Statement', s:palette.red, s:palette.none)
" call s:HL('Macro', s:palette.purple, s:palette.none)
" call s:HL('Error', s:palette.red, s:palette.none)
" call s:HL('Label', s:palette.purple, s:palette.none)
" call s:HL('Special', s:palette.purple, s:palette.none)
" call s:HL('SpecialChar', s:palette.purple, s:palette.none)
" call s:HL('Boolean', s:palette.purple, s:palette.none)
" call s:HL('String', s:palette.yellow, s:palette.none)
" call s:HL('Character', s:palette.yellow, s:palette.none)
" call s:HL('Number', s:palette.purple, s:palette.none)
" call s:HL('Float', s:palette.purple, s:palette.none)
" call s:HL('Function', s:palette.green, s:palette.none)
" call s:HL('Operator', s:palette.red, s:palette.none)
" call s:HL('Title', s:palette.red, s:palette.none, 'bold')
" call s:HL('Tag', s:palette.orange, s:palette.none)
" call s:HL('Delimiter', s:palette.fg, s:palette.none)
" call s:HL('Comment', s:palette.grey, s:palette.none, 'italic')
" call s:HL('SpecialComment', s:palette.grey, s:palette.none, 'italic')
" call s:HL('Todo', s:palette.blue, s:palette.none, 'italic')
" call s:HL('Ignore', s:palette.grey, s:palette.none)
" call s:HL('Underlined', s:palette.none, s:palette.none, 'underline')
" call s:HL('Fg', s:palette.fg, s:palette.none)
" call s:HL('Grey', s:palette.grey, s:palette.none)
" call s:HL('Red', s:palette.red, s:palette.none)
" call s:HL('Orange', s:palette.orange, s:palette.none)
" call s:HL('Yellow', s:palette.yellow, s:palette.none)
" call s:HL('Green', s:palette.green, s:palette.none)
" call s:HL('Blue', s:palette.blue, s:palette.none)
" call s:HL('Purple', s:palette.purple, s:palette.none)
" call s:HL('RedItalic', s:palette.red, s:palette.none, 'italic')
" call s:HL('BlueItalic', s:palette.blue, s:palette.none, 'italic')
" call s:HL('OrangeItalic', s:palette.orange, s:palette.none, 'italic')
" let s:terminal = {
" 			\ 'black':s:palette.black,'red':s:palette.red,'yellow':s:palette.yellow,'green':s:palette.green,
" 			\ 'cyan':s:palette.orange,'blue':s:palette.blue,'purple':s:palette.purple,'white':s:palette.fg
" 			\ }
" let g:terminal_ansi_colors = [s:terminal.black[0], s:terminal.red[0], s:terminal.green[0], s:terminal.yellow[0],
" 			\ s:terminal.blue[0], s:terminal.purple[0], s:terminal.cyan[0], s:terminal.white[0], s:terminal.black[0], s:terminal.red[0],
" 			\ s:terminal.green[0], s:terminal.yellow[0], s:terminal.blue[0], s:terminal.purple[0], s:terminal.cyan[0], s:terminal.white[0]]

" " vim: set fen ft=vim fdm=marker fmr={{{,}}}:

set background=dark

highlight clear

if exists("syntax_on")
  syntax reset
endif

set t_Co=256

let g:colors_name="onedark"

" Set to "256" for 256-color terminals, or
" set to "16" to use your terminal emulator's native colors
" (a 16-color palette for this color scheme is available; see
" < https://github.com/joshdick/onedark.vim/blob/master/README.md >
" for more information.)
if !exists("g:onedark_termcolors")
  let g:onedark_termcolors = 256
endif

" Not all terminals support italics properly. If yours does, opt-in.
if !exists("g:onedark_terminal_italics")
  let g:onedark_terminal_italics = 0
endif

" This function is based on one from FlatColor: https://github.com/MaxSt/FlatColor/
" Which in turn was based on one found in hemisu: https://github.com/noahfrederick/vim-hemisu/
function! s:h(group, style)
  if g:onedark_terminal_italics == 0
    if has_key(a:style, "cterm") && a:style["cterm"] == "italic"
      unlet a:style.cterm
    endif
    if has_key(a:style, "gui") && a:style["gui"] == "italic"
      unlet a:style.gui
    endif
  endif
  if g:onedark_termcolors == 16
    let l:ctermfg = (has_key(a:style, "fg") ? a:style.fg.cterm16 : "NONE")
    let l:ctermbg = (has_key(a:style, "bg") ? a:style.bg.cterm16 : "NONE")
  else
    let l:ctermfg = (has_key(a:style, "fg") ? a:style.fg.cterm : "NONE")
    let l:ctermbg = (has_key(a:style, "bg") ? a:style.bg.cterm : "NONE")
  endif
  execute "highlight" a:group
    \ "guifg="   (has_key(a:style, "fg")    ? a:style.fg.gui   : "NONE")
    \ "guibg="   (has_key(a:style, "bg")    ? a:style.bg.gui   : "NONE")
    \ "guisp="   (has_key(a:style, "sp")    ? a:style.sp.gui   : "NONE")
    \ "gui="     (has_key(a:style, "gui")   ? a:style.gui      : "NONE")
    \ "ctermfg=" . l:ctermfg
    \ "ctermbg=" . l:ctermbg
    \ "cterm="   (has_key(a:style, "cterm") ? a:style.cterm    : "NONE")
endfunction

" +-----------------+
" | Color Variables |
" +-----------------+

let s:red = { "gui": "#E06C75", "cterm": "204", "cterm16": "1" } " Alternate cterm: 168
let s:dark_red = { "gui": "#BE5046", "cterm": "196", "cterm16": "9" }

let s:green = { "gui": "#98C379", "cterm": "114", "cterm16": "2" }

let s:yellow = { "gui": "#E5C07b", "cterm": "180", "cterm16": "3" }
let s:dark_yellow = { "gui": "#D19A66", "cterm": "173", "cterm16": "11" }

let s:blue = { "gui": "#61AFEF", "cterm": "39", "cterm16": "4" } " Alternate cterm: 75

let s:purple = { "gui": "#C678DD", "cterm": "170", "cterm16": "5" } " Alternate cterm: 176

let s:cyan = { "gui": "#56B6C2", "cterm": "38", "cterm16": "6" } " Alternate cterm: 73

let s:white = { "gui": "#ABB2BF", "cterm": "145", "cterm16" : "7" }

let s:black = { "gui": "#282C34", "cterm": "235", "cterm16": "0" }
let s:visual_black = { "gui": "NONE", "cterm": "NONE", "cterm16": s:black.cterm16 } " Black out selected text in 16-color visual mode

let s:comment_grey = { "gui": "#5C6370", "cterm": "59", "cterm16": "15" }
let s:gutter_fg_grey = { "gui": "#636D83", "cterm": "238", "cterm16": "15" }
let s:cursor_grey =  { "gui": "#2C323C", "cterm": "236", "cterm16": "8" }
let s:visual_grey = { "gui": "#3E4452", "cterm": "237", "cterm16": "15" }
let s:menu_grey = { "gui": s:visual_grey.gui, "cterm": s:visual_grey.cterm, "cterm16": "8" }
let s:special_grey = { "gui": "#3B4048", "cterm": "238", "cterm16": "15" }
let s:vertsplit = { "gui": "#181A1F", "cterm": "59", "cterm16": "15" }

" +---------------------------------------------------------+
" | Syntax Groups (descriptions and ordering from `:h w18`) |
" +---------------------------------------------------------+

call s:h("Comment", { "fg": s:comment_grey, "gui": "italic", "cterm": "italic" }) " any comment
call s:h("Constant", { "fg": s:cyan }) " any constant
call s:h("String", { "fg": s:green }) " a string constant: "this is a string"
call s:h("Character", { "fg": s:green }) " a character constant: 'c', '\n'
call s:h("Number", { "fg": s:dark_yellow }) " a number constant: 234, 0xff
call s:h("Boolean", { "fg": s:dark_yellow }) " a boolean constant: TRUE, false
call s:h("Float", { "fg": s:dark_yellow }) " a floating point constant: 2.3e10
call s:h("Identifier", { "fg": s:red }) " any variable name
call s:h("Function", { "fg": s:blue }) " function name (also: methods for classes)
call s:h("Statement", { "fg": s:purple }) " any statement
call s:h("Conditional", { "fg": s:purple }) " if, then, else, endif, switch, etc.
call s:h("Repeat", { "fg": s:purple }) " for, do, while, etc.
call s:h("Label", { "fg": s:purple }) " case, default, etc.
call s:h("Operator", { "fg": s:purple }) " sizeof", "+", "*", etc.
call s:h("Keyword", { "fg": s:red }) " any other keyword
call s:h("Exception", { "fg": s:purple }) " try, catch, throw
call s:h("PreProc", { "fg": s:yellow }) " generic Preprocessor
call s:h("Include", { "fg": s:blue }) " preprocessor #include
call s:h("Define", { "fg": s:purple }) " preprocessor #define
call s:h("Macro", { "fg": s:purple }) " same as Define
call s:h("PreCondit", { "fg": s:yellow }) " preprocessor #if, #else, #endif, etc.
call s:h("Type", { "fg": s:yellow }) " int, long, char, etc.
call s:h("StorageClass", { "fg": s:yellow }) " static, register, volatile, etc.
call s:h("Structure", { "fg": s:yellow }) " struct, union, enum, etc.
call s:h("Typedef", { "fg": s:yellow }) " A typedef
call s:h("Special", { "fg": s:blue }) " any special symbol
call s:h("SpecialChar", {}) " special character in a constant
call s:h("Tag", {}) " you can use CTRL-] on this
call s:h("Delimiter", {}) " character that needs attention
call s:h("SpecialComment", {}) " special things inside a comment
call s:h("Debug", {}) " debugging statements
call s:h("Underlined", {}) " text that stands out, HTML links
call s:h("Ignore", {}) " left blank, hidden
call s:h("Error", { "fg": s:red }) " any erroneous construct
call s:h("Todo", { "fg": s:purple }) " anything that needs extra attention; mostly the keywords TODO FIXME and XXX

" +----------------------------------------------------------------------+
" | Highlighting Groups (descriptions and ordering from `:h hitest.vim`) |
" +----------------------------------------------------------------------+

call s:h("ColorColumn", { "bg": s:cursor_grey }) " used for the columns set with 'colorcolumn'
call s:h("Conceal", {}) " placeholder characters substituted for concealed text (see 'conceallevel')
call s:h("Cursor", { "fg": s:black, "bg": s:blue }) " the character under the cursor
call s:h("CursorIM", {}) " like Cursor, but used when in IME mode
call s:h("CursorColumn", { "bg": s:cursor_grey }) " the screen column that the cursor is in when 'cursorcolumn' is set
call s:h("CursorLine", { "bg": s:cursor_grey }) " the screen line that the cursor is in when 'cursorline' is set
call s:h("Directory", { "fg": s:blue }) " directory names (and other special names in listings)
call s:h("DiffAdd", { "fg": s:green }) " diff mode: Added line
call s:h("DiffChange", { "fg": s:dark_yellow }) " diff mode: Changed line
call s:h("DiffDelete", { "fg": s:red }) " diff mode: Deleted line
call s:h("DiffText", { "fg": s:blue }) " diff mode: Changed text within a changed line
call s:h("ErrorMsg", {}) " error messages on the command line
call s:h("VertSplit", { "fg": s:vertsplit }) " the column separating vertically split windows
call s:h("Folded", { "fg": s:comment_grey }) " line used for closed folds
call s:h("FoldColumn", {}) " 'foldcolumn'
call s:h("SignColumn", {}) " column where signs are displayed
call s:h("IncSearch", { "fg": s:black, "bg": s:yellow }) " 'incsearch' highlighting; also used for the text replaced with ":s///c"
call s:h("LineNr", { "fg": s:gutter_fg_grey }) " Line number for ":number" and ":#" commands, and when 'number' or 'relativenumber' option is set.
call s:h("CursorLineNr", {}) " Like LineNr when 'cursorline' or 'relativenumber' is set for the cursor line.
call s:h("MatchParen", { "fg": s:blue, "gui": "underline" }) " The character under the cursor or just before it, if it is a paired bracket, and its match.
call s:h("ModeMsg", {}) " 'showmode' message (e.g., "-- INSERT --")
call s:h("MoreMsg", {}) " more-prompt
call s:h("NonText", { "fg": s:special_grey }) " '~' and '@' at the end of the window, characters from 'showbreak' and other characters that do not really exist in the text (e.g., ">" displayed when a double-wide character doesn't fit at the end of the line).
call s:h("Normal", { "fg": s:white, "bg": s:black }) " normal text
call s:h("Pmenu", { "bg": s:menu_grey }) " Popup menu: normal item.
call s:h("PmenuSel", { "bg": s:black }) " Popup menu: selected item.
call s:h("PmenuSbar", { "bg": s:special_grey }) " Popup menu: scrollbar.
call s:h("PmenuThumb", { "bg": s:white }) " Popup menu: Thumb of the scrollbar.
call s:h("Question", { "fg": s:purple }) " hit-enter prompt and yes/no questions
call s:h("Search", { "fg": s:black, "bg": s:yellow }) " Last search pattern highlighting (see 'hlsearch'). Also used for highlighting the current line in the quickfix window and similar items that need to stand out.
call s:h("SpecialKey", { "fg": s:special_grey }) " Meta and special keys listed with ":map", also for text used to show unprintable characters in the text, 'listchars'. Generally: text that is displayed differently from what it really is.
call s:h("SpellBad", { "fg": s:red, "gui": "underline", "cterm": "underline" }) " Word that is not recognized by the spellchecker. This will be combined with the highlighting used otherwise.
call s:h("SpellCap", { "fg": s:dark_yellow }) " Word that should start with a capital. This will be combined with the highlighting used otherwise.
call s:h("SpellLocal", { "fg": s:dark_yellow }) " Word that is recognized by the spellchecker as one that is used in another region. This will be combined with the highlighting used otherwise.
call s:h("SpellRare", { "fg": s:dark_yellow }) " Word that is recognized by the spellchecker as one that is hardly ever used. spell This will be combined with the highlighting used otherwise.
call s:h("StatusLine", { "fg": s:white, "bg": s:cursor_grey }) " status line of current window
call s:h("StatusLineNC", { "fg": s:comment_grey }) " status lines of not-current windows Note: if this is equal to "StatusLine" Vim will use "^^^" in the status line of the current window.
call s:h("TabLine", { "fg": s:comment_grey }) " tab pages line, not active tab page label
call s:h("TabLineFill", {}) " tab pages line, where there are no labels
call s:h("TabLineSel", { "fg": s:white }) " tab pages line, active tab page label
call s:h("Title", { "fg": s:green }) " titles for output from ":set all", ":autocmd" etc.
call s:h("Visual", { "fg": s:visual_black, "bg": s:visual_grey }) " Visual mode selection
call s:h("VisualNOS", { "bg": s:visual_grey }) " Visual mode selection when vim is "Not Owning the Selection". Only X11 Gui's gui-x11 and xterm-clipboard supports this.
call s:h("WarningMsg", { "fg": s:red }) " warning messages
call s:h("WildMenu", {}) " current match in 'wildmenu' completion

" +--------------------------------+
" | Language-Specific Highlighting |
" +--------------------------------+

" CSS
call s:h("cssAttrComma", { "fg": s:purple })
call s:h("cssAttributeSelector", { "fg": s:green })
call s:h("cssBraces", { "fg": s:white })
call s:h("cssClassName", { "fg": s:dark_yellow })
call s:h("cssClassNameDot", { "fg": s:dark_yellow })
call s:h("cssDefinition", { "fg": s:purple })
call s:h("cssFontAttr", { "fg": s:dark_yellow })
call s:h("cssFontDescriptor", { "fg": s:purple })
call s:h("cssFunctionName", { "fg": s:blue })
call s:h("cssIdentifier", { "fg": s:blue })
call s:h("cssImportant", { "fg": s:purple })
call s:h("cssInclude", { "fg": s:white })
call s:h("cssIncludeKeyword", { "fg": s:purple })
call s:h("cssMediaType", { "fg": s:dark_yellow })
call s:h("cssProp", { "fg": s:white })
call s:h("cssPseudoClassId", { "fg": s:dark_yellow })
call s:h("cssSelectorOp", { "fg": s:purple })
call s:h("cssSelectorOp2", { "fg": s:purple })
call s:h("cssTagName", { "fg": s:red })

" HTML
call s:h("htmlTitle", { "fg": s:white })
call s:h("htmlArg", { "fg": s:dark_yellow })
call s:h("htmlEndTag", { "fg": s:white })
call s:h("htmlH1", { "fg": s:white })
call s:h("htmlLink", { "fg": s:purple })
call s:h("htmlSpecialChar", { "fg": s:dark_yellow })
call s:h("htmlSpecialTagName", { "fg": s:red })
call s:h("htmlTag", { "fg": s:white })
call s:h("htmlTagName", { "fg": s:red })

" JavaScript
call s:h("javaScriptBraces", { "fg": s:white })
call s:h("javaScriptFunction", { "fg": s:purple })
call s:h("javaScriptIdentifier", { "fg": s:purple })
call s:h("javaScriptNull", { "fg": s:dark_yellow })
call s:h("javaScriptNumber", { "fg": s:dark_yellow })
call s:h("javaScriptRequire", { "fg": s:cyan })
call s:h("javaScriptReserved", { "fg": s:purple })
" https://github.com/pangloss/vim-javascript
call s:h("jsArrowFunction", { "fg": s:purple })
call s:h("jsClassKeywords", { "fg": s:purple })
call s:h("jsDocParam", { "fg": s:blue })
call s:h("jsDocTags", { "fg": s:purple })
call s:h("jsFuncCall", { "fg": s:blue })
call s:h("jsFunction", { "fg": s:purple })
call s:h("jsGlobalObjects", { "fg": s:yellow })
call s:h("jsModuleWords", { "fg": s:purple })
call s:h("jsModules", { "fg": s:purple })
call s:h("jsNull", { "fg": s:dark_yellow })
call s:h("jsOperator", { "fg": s:purple })
call s:h("jsStorageClass", { "fg": s:purple })
call s:h("jsTemplateBraces", { "fg": s:dark_red })
call s:h("jsTemplateVar", { "fg": s:green })
call s:h("jsThis", { "fg": s:red })
call s:h("jsUndefined", { "fg": s:dark_yellow })
" https://github.com/othree/yajs.vim
call s:h("javascriptArrowFunc", { "fg": s:purple })
call s:h("javascriptClassExtends", { "fg": s:purple })
call s:h("javascriptClassKeyword", { "fg": s:purple })
call s:h("javascriptDocNotation", { "fg": s:purple })
call s:h("javascriptDocParamName", { "fg": s:blue })
call s:h("javascriptDocTags", { "fg": s:purple })
call s:h("javascriptEndColons", { "fg": s:white })
call s:h("javascriptExport", { "fg": s:purple })
call s:h("javascriptFuncArg", { "fg": s:white })
call s:h("javascriptFuncKeyword", { "fg": s:purple })
call s:h("javascriptIdentifier", { "fg": s:red })
call s:h("javascriptImport", { "fg": s:purple })
call s:h("javascriptObjectLabel", { "fg": s:white })
call s:h("javascriptOpSymbol", { "fg": s:cyan })
call s:h("javascriptOpSymbols", { "fg": s:cyan })
call s:h("javascriptPropertyName", { "fg": s:green })
call s:h("javascriptTemplateSB", { "fg": s:dark_red })
call s:h("javascriptVariable", { "fg": s:purple })

" JSON
call s:h("jsonCommentError", { "fg": s:white })
call s:h("jsonKeyword", { "fg": s:red })
call s:h("jsonBoolean", { "fg": s:dark_yellow })
call s:h("jsonNumber", { "fg": s:dark_yellow })
call s:h("jsonQuote", { "fg": s:white })
call s:h("jsonMissingCommaError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonNoQuotesError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonNumError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonString", { "fg": s:green })
call s:h("jsonStringSQError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonSemicolonError", { "fg": s:red, "gui": "reverse" })

" Markdown
call s:h("markdownCode", { "fg": s:green })
call s:h("markdownCodeBlock", { "fg": s:green })
call s:h("markdownCodeDelimiter", { "fg": s:green })
call s:h("markdownHeadingDelimiter", { "fg": s:red })
call s:h("markdownRule", { "fg": s:comment_grey })
call s:h("markdownHeadingRule", { "fg": s:comment_grey })
call s:h("markdownH1", { "fg": s:red })
call s:h("markdownH2", { "fg": s:red })
call s:h("markdownH3", { "fg": s:red })
call s:h("markdownH4", { "fg": s:red })
call s:h("markdownH5", { "fg": s:red })
call s:h("markdownH6", { "fg": s:red })
call s:h("markdownIdDelimiter", { "fg": s:purple })
call s:h("markdownId", { "fg": s:purple })
call s:h("markdownBlockquote", { "fg": s:comment_grey })
call s:h("markdownItalic", { "fg": s:purple, "gui": "italic", "cterm": "italic" })
call s:h("markdownBold", { "fg": s:dark_yellow, "gui": "bold", "cterm": "bold" })
call s:h("markdownListMarker", { "fg": s:red })
call s:h("markdownOrderedListMarker", { "fg": s:red })
call s:h("markdownIdDeclaration", { "fg": s:blue })
call s:h("markdownLinkText", { "fg": s:blue })
call s:h("markdownLinkDelimiter", { "fg": s:white })
call s:h("markdownUrl", { "fg": s:purple })

" Ruby
call s:h("rubyBlockParameter", { "fg": s:red})
call s:h("rubyBlockParameterList", { "fg": s:red })
call s:h("rubyClass", { "fg": s:purple})
call s:h("rubyConstant", { "fg": s:yellow})
call s:h("rubyControl", { "fg": s:purple })
call s:h("rubyEscape", { "fg": s:red})
call s:h("rubyFunction", { "fg": s:blue})
call s:h("rubyGlobalVariable", { "fg": s:red})
call s:h("rubyInclude", { "fg": s:blue})
call s:h("rubyIncluderubyGlobalVariable", { "fg": s:red})
call s:h("rubyInstanceVariable", { "fg": s:red})
call s:h("rubyInterpolation", { "fg": s:cyan })
call s:h("rubyInterpolationDelimiter", { "fg": s:red })
call s:h("rubyInterpolationDelimiter", { "fg": s:red})
call s:h("rubyRegexp", { "fg": s:cyan})
call s:h("rubyRegexpDelimiter", { "fg": s:cyan})
call s:h("rubyStringDelimiter", { "fg": s:green})
call s:h("rubySymbol", { "fg": s:cyan})

" Sass
call s:h("sassAmpersand", { "fg": s:red })
call s:h("sassClass", { "fg": s:dark_yellow })
call s:h("sassControl", { "fg": s:purple })
call s:h("sassExtend", { "fg": s:purple })
call s:h("sassFor", { "fg": s:white })
call s:h("sassFunction", { "fg": s:cyan })
call s:h("sassId", { "fg": s:blue })
call s:h("sassInclude", { "fg": s:purple })
call s:h("sassMedia", { "fg": s:purple })
call s:h("sassMediaOperators", { "fg": s:white })
call s:h("sassMixin", { "fg": s:purple })
call s:h("sassMixinName", { "fg": s:blue })
call s:h("sassMixing", { "fg": s:purple })

" TypeScript
call s:h("typescriptReserved", { "fg": s:purple })
call s:h("typescriptEndColons", { "fg": s:white })
call s:h("typescriptBraces", { "fg": s:white })

" XML
call s:h("xmlAttrib", { "fg": s:dark_yellow })
call s:h("xmlEndTag", { "fg": s:red })
call s:h("xmlTag", { "fg": s:red })
call s:h("xmlTagName", { "fg": s:red })

" +---------------------+
" | Plugin Highlighting |
" +---------------------+

" airblade/vim-gitgutter
hi link GitGutterAdd    SignifySignAdd
hi link GitGutterChange SignifySignChange
hi link GitGutterDelete SignifySignDelete

" mhinz/vim-signify
call s:h("SignifySignAdd", { "fg": s:green })
call s:h("SignifySignChange", { "fg": s:yellow })
call s:h("SignifySignDelete", { "fg": s:red })

" neomake/neomake
call s:h("NeomakeWarningSign", { "fg": s:yellow })
call s:h("NeomakeErrorSign", { "fg": s:red })
call s:h("NeomakeInfoSign", { "fg": s:blue })

" tpope/vim-fugitive
call s:h("diffAdded", { "fg": s:green })
call s:h("diffRemoved", { "fg": s:red })

" +------------------+
" | Git Highlighting |
" +------------------+

call s:h("gitcommitComment", { "fg": s:comment_grey })
call s:h("gitcommitUnmerged", { "fg": s:green })
call s:h("gitcommitOnBranch", {})
call s:h("gitcommitBranch", { "fg": s:purple })
call s:h("gitcommitDiscardedType", { "fg": s:red })
call s:h("gitcommitSelectedType", { "fg": s:green })
call s:h("gitcommitHeader", {})
call s:h("gitcommitUntrackedFile", { "fg": s:cyan })
call s:h("gitcommitDiscardedFile", { "fg": s:red })
call s:h("gitcommitSelectedFile", { "fg": s:green })
call s:h("gitcommitUnmergedFile", { "fg": s:yellow })
call s:h("gitcommitFile", {})
hi link gitcommitNoBranch gitcommitBranch
hi link gitcommitUntracked gitcommitComment
hi link gitcommitDiscarded gitcommitComment
hi link gitcommitSelected gitcommitComment
hi link gitcommitDiscardedArrow gitcommitDiscardedFile
hi link gitcommitSelectedArrow gitcommitSelectedFile
hi link gitcommitUnmergedArrow gitcommitUnmergedFile

" +------------------------+
" | Neovim terminal colors |
" +------------------------+

if has("nvim")
  let g:terminal_color_0 =  s:black.gui
  let g:terminal_color_1 =  s:red.gui
  let g:terminal_color_2 =  s:green.gui
  let g:terminal_color_3 =  s:yellow.gui
  let g:terminal_color_4 =  s:blue.gui
  let g:terminal_color_5 =  s:purple.gui
  let g:terminal_color_6 =  s:cyan.gui
  let g:terminal_color_7 =  s:white.gui
  let g:terminal_color_8 =  s:visual_grey.gui
  let g:terminal_color_9 =  s:dark_red.gui
  let g:terminal_color_10 = s:green.gui " No dark version
  let g:terminal_color_11 = s:dark_yellow.gui
  let g:terminal_color_12 = s:blue.gui " No dark version
  let g:terminal_color_13 = s:purple.gui " No dark version
  let g:terminal_color_14 = s:cyan.gui " No dark version
  let g:terminal_color_15 = s:comment_grey.gui
  let g:terminal_color_background = g:terminal_color_0
  let g:terminal_color_foreground = g:terminal_color_7
endifset background=dark

highlight clear

if exists("syntax_on")
  syntax reset
endif

set t_Co=256

let g:colors_name="onedark"

" Set to "256" for 256-color terminals, or
" set to "16" to use your terminal emulator's native colors
" (a 16-color palette for this color scheme is available; see
" < https://github.com/joshdick/onedark.vim/blob/master/README.md >
" for more information.)
if !exists("g:onedark_termcolors")
  let g:onedark_termcolors = 256
endif

" Not all terminals support italics properly. If yours does, opt-in.
if !exists("g:onedark_terminal_italics")
  let g:onedark_terminal_italics = 0
endif

" This function is based on one from FlatColor: https://github.com/MaxSt/FlatColor/
" Which in turn was based on one found in hemisu: https://github.com/noahfrederick/vim-hemisu/
function! s:h(group, style)
  if g:onedark_terminal_italics == 0
    if has_key(a:style, "cterm") && a:style["cterm"] == "italic"
      unlet a:style.cterm
    endif
    if has_key(a:style, "gui") && a:style["gui"] == "italic"
      unlet a:style.gui
    endif
  endif
  if g:onedark_termcolors == 16
    let l:ctermfg = (has_key(a:style, "fg") ? a:style.fg.cterm16 : "NONE")
    let l:ctermbg = (has_key(a:style, "bg") ? a:style.bg.cterm16 : "NONE")
  else
    let l:ctermfg = (has_key(a:style, "fg") ? a:style.fg.cterm : "NONE")
    let l:ctermbg = (has_key(a:style, "bg") ? a:style.bg.cterm : "NONE")
  endif
  execute "highlight" a:group
    \ "guifg="   (has_key(a:style, "fg")    ? a:style.fg.gui   : "NONE")
    \ "guibg="   (has_key(a:style, "bg")    ? a:style.bg.gui   : "NONE")
    \ "guisp="   (has_key(a:style, "sp")    ? a:style.sp.gui   : "NONE")
    \ "gui="     (has_key(a:style, "gui")   ? a:style.gui      : "NONE")
    \ "ctermfg=" . l:ctermfg
    \ "ctermbg=" . l:ctermbg
    \ "cterm="   (has_key(a:style, "cterm") ? a:style.cterm    : "NONE")
endfunction

" +-----------------+
" | Color Variables |
" +-----------------+

let s:red = { "gui": "#E06C75", "cterm": "204", "cterm16": "1" } " Alternate cterm: 168
let s:dark_red = { "gui": "#BE5046", "cterm": "196", "cterm16": "9" }

let s:green = { "gui": "#98C379", "cterm": "114", "cterm16": "2" }

let s:yellow = { "gui": "#E5C07b", "cterm": "180", "cterm16": "3" }
let s:dark_yellow = { "gui": "#D19A66", "cterm": "173", "cterm16": "11" }

let s:blue = { "gui": "#61AFEF", "cterm": "39", "cterm16": "4" } " Alternate cterm: 75

let s:purple = { "gui": "#C678DD", "cterm": "170", "cterm16": "5" } " Alternate cterm: 176

let s:cyan = { "gui": "#56B6C2", "cterm": "38", "cterm16": "6" } " Alternate cterm: 73

let s:white = { "gui": "#ABB2BF", "cterm": "145", "cterm16" : "7" }

let s:black = { "gui": "#282C34", "cterm": "235", "cterm16": "0" }
let s:visual_black = { "gui": "NONE", "cterm": "NONE", "cterm16": s:black.cterm16 } " Black out selected text in 16-color visual mode

let s:comment_grey = { "gui": "#5C6370", "cterm": "59", "cterm16": "15" }
let s:gutter_fg_grey = { "gui": "#636D83", "cterm": "238", "cterm16": "15" }
let s:cursor_grey =  { "gui": "#2C323C", "cterm": "236", "cterm16": "8" }
let s:visual_grey = { "gui": "#3E4452", "cterm": "237", "cterm16": "15" }
let s:menu_grey = { "gui": s:visual_grey.gui, "cterm": s:visual_grey.cterm, "cterm16": "8" }
let s:special_grey = { "gui": "#3B4048", "cterm": "238", "cterm16": "15" }
let s:vertsplit = { "gui": "#181A1F", "cterm": "59", "cterm16": "15" }

" +---------------------------------------------------------+
" | Syntax Groups (descriptions and ordering from `:h w18`) |
" +---------------------------------------------------------+

call s:h("Comment", { "fg": s:comment_grey, "gui": "italic", "cterm": "italic" }) " any comment
call s:h("Constant", { "fg": s:cyan }) " any constant
call s:h("String", { "fg": s:green }) " a string constant: "this is a string"
call s:h("Character", { "fg": s:green }) " a character constant: 'c', '\n'
call s:h("Number", { "fg": s:dark_yellow }) " a number constant: 234, 0xff
call s:h("Boolean", { "fg": s:dark_yellow }) " a boolean constant: TRUE, false
call s:h("Float", { "fg": s:dark_yellow }) " a floating point constant: 2.3e10
call s:h("Identifier", { "fg": s:red }) " any variable name
call s:h("Function", { "fg": s:blue }) " function name (also: methods for classes)
call s:h("Statement", { "fg": s:purple }) " any statement
call s:h("Conditional", { "fg": s:purple }) " if, then, else, endif, switch, etc.
call s:h("Repeat", { "fg": s:purple }) " for, do, while, etc.
call s:h("Label", { "fg": s:purple }) " case, default, etc.
call s:h("Operator", { "fg": s:purple }) " sizeof", "+", "*", etc.
call s:h("Keyword", { "fg": s:red }) " any other keyword
call s:h("Exception", { "fg": s:purple }) " try, catch, throw
call s:h("PreProc", { "fg": s:yellow }) " generic Preprocessor
call s:h("Include", { "fg": s:blue }) " preprocessor #include
call s:h("Define", { "fg": s:purple }) " preprocessor #define
call s:h("Macro", { "fg": s:purple }) " same as Define
call s:h("PreCondit", { "fg": s:yellow }) " preprocessor #if, #else, #endif, etc.
call s:h("Type", { "fg": s:yellow }) " int, long, char, etc.
call s:h("StorageClass", { "fg": s:yellow }) " static, register, volatile, etc.
call s:h("Structure", { "fg": s:yellow }) " struct, union, enum, etc.
call s:h("Typedef", { "fg": s:yellow }) " A typedef
call s:h("Special", { "fg": s:blue }) " any special symbol
call s:h("SpecialChar", {}) " special character in a constant
call s:h("Tag", {}) " you can use CTRL-] on this
call s:h("Delimiter", {}) " character that needs attention
call s:h("SpecialComment", {}) " special things inside a comment
call s:h("Debug", {}) " debugging statements
call s:h("Underlined", {}) " text that stands out, HTML links
call s:h("Ignore", {}) " left blank, hidden
call s:h("Error", { "fg": s:red }) " any erroneous construct
call s:h("Todo", { "fg": s:purple }) " anything that needs extra attention; mostly the keywords TODO FIXME and XXX

" +----------------------------------------------------------------------+
" | Highlighting Groups (descriptions and ordering from `:h hitest.vim`) |
" +----------------------------------------------------------------------+

call s:h("ColorColumn", { "bg": s:cursor_grey }) " used for the columns set with 'colorcolumn'
call s:h("Conceal", {}) " placeholder characters substituted for concealed text (see 'conceallevel')
call s:h("Cursor", { "fg": s:black, "bg": s:blue }) " the character under the cursor
call s:h("CursorIM", {}) " like Cursor, but used when in IME mode
call s:h("CursorColumn", { "bg": s:cursor_grey }) " the screen column that the cursor is in when 'cursorcolumn' is set
call s:h("CursorLine", { "bg": s:cursor_grey }) " the screen line that the cursor is in when 'cursorline' is set
call s:h("Directory", { "fg": s:blue }) " directory names (and other special names in listings)
call s:h("DiffAdd", { "fg": s:green }) " diff mode: Added line
call s:h("DiffChange", { "fg": s:dark_yellow }) " diff mode: Changed line
call s:h("DiffDelete", { "fg": s:red }) " diff mode: Deleted line
call s:h("DiffText", { "fg": s:blue }) " diff mode: Changed text within a changed line
call s:h("ErrorMsg", {}) " error messages on the command line
call s:h("VertSplit", { "fg": s:vertsplit }) " the column separating vertically split windows
call s:h("Folded", { "fg": s:comment_grey }) " line used for closed folds
call s:h("FoldColumn", {}) " 'foldcolumn'
call s:h("SignColumn", {}) " column where signs are displayed
call s:h("IncSearch", { "fg": s:black, "bg": s:yellow }) " 'incsearch' highlighting; also used for the text replaced with ":s///c"
call s:h("LineNr", { "fg": s:gutter_fg_grey }) " Line number for ":number" and ":#" commands, and when 'number' or 'relativenumber' option is set.
call s:h("CursorLineNr", {}) " Like LineNr when 'cursorline' or 'relativenumber' is set for the cursor line.
call s:h("MatchParen", { "fg": s:blue, "gui": "underline" }) " The character under the cursor or just before it, if it is a paired bracket, and its match.
call s:h("ModeMsg", {}) " 'showmode' message (e.g., "-- INSERT --")
call s:h("MoreMsg", {}) " more-prompt
call s:h("NonText", { "fg": s:special_grey }) " '~' and '@' at the end of the window, characters from 'showbreak' and other characters that do not really exist in the text (e.g., ">" displayed when a double-wide character doesn't fit at the end of the line).
call s:h("Normal", { "fg": s:white, "bg": s:black }) " normal text
call s:h("Pmenu", { "bg": s:menu_grey }) " Popup menu: normal item.
call s:h("PmenuSel", { "bg": s:black }) " Popup menu: selected item.
call s:h("PmenuSbar", { "bg": s:special_grey }) " Popup menu: scrollbar.
call s:h("PmenuThumb", { "bg": s:white }) " Popup menu: Thumb of the scrollbar.
call s:h("Question", { "fg": s:purple }) " hit-enter prompt and yes/no questions
call s:h("Search", { "fg": s:black, "bg": s:yellow }) " Last search pattern highlighting (see 'hlsearch'). Also used for highlighting the current line in the quickfix window and similar items that need to stand out.
call s:h("SpecialKey", { "fg": s:special_grey }) " Meta and special keys listed with ":map", also for text used to show unprintable characters in the text, 'listchars'. Generally: text that is displayed differently from what it really is.
call s:h("SpellBad", { "fg": s:red, "gui": "underline", "cterm": "underline" }) " Word that is not recognized by the spellchecker. This will be combined with the highlighting used otherwise.
call s:h("SpellCap", { "fg": s:dark_yellow }) " Word that should start with a capital. This will be combined with the highlighting used otherwise.
call s:h("SpellLocal", { "fg": s:dark_yellow }) " Word that is recognized by the spellchecker as one that is used in another region. This will be combined with the highlighting used otherwise.
call s:h("SpellRare", { "fg": s:dark_yellow }) " Word that is recognized by the spellchecker as one that is hardly ever used. spell This will be combined with the highlighting used otherwise.
call s:h("StatusLine", { "fg": s:white, "bg": s:cursor_grey }) " status line of current window
call s:h("StatusLineNC", { "fg": s:comment_grey }) " status lines of not-current windows Note: if this is equal to "StatusLine" Vim will use "^^^" in the status line of the current window.
call s:h("TabLine", { "fg": s:comment_grey }) " tab pages line, not active tab page label
call s:h("TabLineFill", {}) " tab pages line, where there are no labels
call s:h("TabLineSel", { "fg": s:white }) " tab pages line, active tab page label
call s:h("Title", { "fg": s:green }) " titles for output from ":set all", ":autocmd" etc.
call s:h("Visual", { "fg": s:visual_black, "bg": s:visual_grey }) " Visual mode selection
call s:h("VisualNOS", { "bg": s:visual_grey }) " Visual mode selection when vim is "Not Owning the Selection". Only X11 Gui's gui-x11 and xterm-clipboard supports this.
call s:h("WarningMsg", { "fg": s:red }) " warning messages
call s:h("WildMenu", {}) " current match in 'wildmenu' completion

" +--------------------------------+
" | Language-Specific Highlighting |
" +--------------------------------+

" CSS
call s:h("cssAttrComma", { "fg": s:purple })
call s:h("cssAttributeSelector", { "fg": s:green })
call s:h("cssBraces", { "fg": s:white })
call s:h("cssClassName", { "fg": s:dark_yellow })
call s:h("cssClassNameDot", { "fg": s:dark_yellow })
call s:h("cssDefinition", { "fg": s:purple })
call s:h("cssFontAttr", { "fg": s:dark_yellow })
call s:h("cssFontDescriptor", { "fg": s:purple })
call s:h("cssFunctionName", { "fg": s:blue })
call s:h("cssIdentifier", { "fg": s:blue })
call s:h("cssImportant", { "fg": s:purple })
call s:h("cssInclude", { "fg": s:white })
call s:h("cssIncludeKeyword", { "fg": s:purple })
call s:h("cssMediaType", { "fg": s:dark_yellow })
call s:h("cssProp", { "fg": s:white })
call s:h("cssPseudoClassId", { "fg": s:dark_yellow })
call s:h("cssSelectorOp", { "fg": s:purple })
call s:h("cssSelectorOp2", { "fg": s:purple })
call s:h("cssTagName", { "fg": s:red })

" HTML
call s:h("htmlTitle", { "fg": s:white })
call s:h("htmlArg", { "fg": s:dark_yellow })
call s:h("htmlEndTag", { "fg": s:white })
call s:h("htmlH1", { "fg": s:white })
call s:h("htmlLink", { "fg": s:purple })
call s:h("htmlSpecialChar", { "fg": s:dark_yellow })
call s:h("htmlSpecialTagName", { "fg": s:red })
call s:h("htmlTag", { "fg": s:white })
call s:h("htmlTagName", { "fg": s:red })

" JavaScript
call s:h("javaScriptBraces", { "fg": s:white })
call s:h("javaScriptFunction", { "fg": s:purple })
call s:h("javaScriptIdentifier", { "fg": s:purple })
call s:h("javaScriptNull", { "fg": s:dark_yellow })
call s:h("javaScriptNumber", { "fg": s:dark_yellow })
call s:h("javaScriptRequire", { "fg": s:cyan })
call s:h("javaScriptReserved", { "fg": s:purple })
" https://github.com/pangloss/vim-javascript
call s:h("jsArrowFunction", { "fg": s:purple })
call s:h("jsClassKeywords", { "fg": s:purple })
call s:h("jsDocParam", { "fg": s:blue })
call s:h("jsDocTags", { "fg": s:purple })
call s:h("jsFuncCall", { "fg": s:blue })
call s:h("jsFunction", { "fg": s:purple })
call s:h("jsGlobalObjects", { "fg": s:yellow })
call s:h("jsModuleWords", { "fg": s:purple })
call s:h("jsModules", { "fg": s:purple })
call s:h("jsNull", { "fg": s:dark_yellow })
call s:h("jsOperator", { "fg": s:purple })
call s:h("jsStorageClass", { "fg": s:purple })
call s:h("jsTemplateBraces", { "fg": s:dark_red })
call s:h("jsTemplateVar", { "fg": s:green })
call s:h("jsThis", { "fg": s:red })
call s:h("jsUndefined", { "fg": s:dark_yellow })
" https://github.com/othree/yajs.vim
call s:h("javascriptArrowFunc", { "fg": s:purple })
call s:h("javascriptClassExtends", { "fg": s:purple })
call s:h("javascriptClassKeyword", { "fg": s:purple })
call s:h("javascriptDocNotation", { "fg": s:purple })
call s:h("javascriptDocParamName", { "fg": s:blue })
call s:h("javascriptDocTags", { "fg": s:purple })
call s:h("javascriptEndColons", { "fg": s:white })
call s:h("javascriptExport", { "fg": s:purple })
call s:h("javascriptFuncArg", { "fg": s:white })
call s:h("javascriptFuncKeyword", { "fg": s:purple })
call s:h("javascriptIdentifier", { "fg": s:red })
call s:h("javascriptImport", { "fg": s:purple })
call s:h("javascriptObjectLabel", { "fg": s:white })
call s:h("javascriptOpSymbol", { "fg": s:cyan })
call s:h("javascriptOpSymbols", { "fg": s:cyan })
call s:h("javascriptPropertyName", { "fg": s:green })
call s:h("javascriptTemplateSB", { "fg": s:dark_red })
call s:h("javascriptVariable", { "fg": s:purple })

" JSON
call s:h("jsonCommentError", { "fg": s:white })
call s:h("jsonKeyword", { "fg": s:red })
call s:h("jsonBoolean", { "fg": s:dark_yellow })
call s:h("jsonNumber", { "fg": s:dark_yellow })
call s:h("jsonQuote", { "fg": s:white })
call s:h("jsonMissingCommaError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonNoQuotesError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonNumError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonString", { "fg": s:green })
call s:h("jsonStringSQError", { "fg": s:red, "gui": "reverse" })
call s:h("jsonSemicolonError", { "fg": s:red, "gui": "reverse" })

" Markdown
call s:h("markdownCode", { "fg": s:green })
call s:h("markdownCodeBlock", { "fg": s:green })
call s:h("markdownCodeDelimiter", { "fg": s:green })
call s:h("markdownHeadingDelimiter", { "fg": s:red })
call s:h("markdownRule", { "fg": s:comment_grey })
call s:h("markdownHeadingRule", { "fg": s:comment_grey })
call s:h("markdownH1", { "fg": s:red })
call s:h("markdownH2", { "fg": s:red })
call s:h("markdownH3", { "fg": s:red })
call s:h("markdownH4", { "fg": s:red })
call s:h("markdownH5", { "fg": s:red })
call s:h("markdownH6", { "fg": s:red })
call s:h("markdownIdDelimiter", { "fg": s:purple })
call s:h("markdownId", { "fg": s:purple })
call s:h("markdownBlockquote", { "fg": s:comment_grey })
call s:h("markdownItalic", { "fg": s:purple, "gui": "italic", "cterm": "italic" })
call s:h("markdownBold", { "fg": s:dark_yellow, "gui": "bold", "cterm": "bold" })
call s:h("markdownListMarker", { "fg": s:red })
call s:h("markdownOrderedListMarker", { "fg": s:red })
call s:h("markdownIdDeclaration", { "fg": s:blue })
call s:h("markdownLinkText", { "fg": s:blue })
call s:h("markdownLinkDelimiter", { "fg": s:white })
call s:h("markdownUrl", { "fg": s:purple })

" Ruby
call s:h("rubyBlockParameter", { "fg": s:red})
call s:h("rubyBlockParameterList", { "fg": s:red })
call s:h("rubyClass", { "fg": s:purple})
call s:h("rubyConstant", { "fg": s:yellow})
call s:h("rubyControl", { "fg": s:purple })
call s:h("rubyEscape", { "fg": s:red})
call s:h("rubyFunction", { "fg": s:blue})
call s:h("rubyGlobalVariable", { "fg": s:red})
call s:h("rubyInclude", { "fg": s:blue})
call s:h("rubyIncluderubyGlobalVariable", { "fg": s:red})
call s:h("rubyInstanceVariable", { "fg": s:red})
call s:h("rubyInterpolation", { "fg": s:cyan })
call s:h("rubyInterpolationDelimiter", { "fg": s:red })
call s:h("rubyInterpolationDelimiter", { "fg": s:red})
call s:h("rubyRegexp", { "fg": s:cyan})
call s:h("rubyRegexpDelimiter", { "fg": s:cyan})
call s:h("rubyStringDelimiter", { "fg": s:green})
call s:h("rubySymbol", { "fg": s:cyan})

" Sass
call s:h("sassAmpersand", { "fg": s:red })
call s:h("sassClass", { "fg": s:dark_yellow })
call s:h("sassControl", { "fg": s:purple })
call s:h("sassExtend", { "fg": s:purple })
call s:h("sassFor", { "fg": s:white })
call s:h("sassFunction", { "fg": s:cyan })
call s:h("sassId", { "fg": s:blue })
call s:h("sassInclude", { "fg": s:purple })
call s:h("sassMedia", { "fg": s:purple })
call s:h("sassMediaOperators", { "fg": s:white })
call s:h("sassMixin", { "fg": s:purple })
call s:h("sassMixinName", { "fg": s:blue })
call s:h("sassMixing", { "fg": s:purple })

" TypeScript
call s:h("typescriptReserved", { "fg": s:purple })
call s:h("typescriptEndColons", { "fg": s:white })
call s:h("typescriptBraces", { "fg": s:white })

" XML
call s:h("xmlAttrib", { "fg": s:dark_yellow })
call s:h("xmlEndTag", { "fg": s:red })
call s:h("xmlTag", { "fg": s:red })
call s:h("xmlTagName", { "fg": s:red })

" +---------------------+
" | Plugin Highlighting |
" +---------------------+

" airblade/vim-gitgutter
hi link GitGutterAdd    SignifySignAdd
hi link GitGutterChange SignifySignChange
hi link GitGutterDelete SignifySignDelete

" mhinz/vim-signify
call s:h("SignifySignAdd", { "fg": s:green })
call s:h("SignifySignChange", { "fg": s:yellow })
call s:h("SignifySignDelete", { "fg": s:red })

" neomake/neomake
call s:h("NeomakeWarningSign", { "fg": s:yellow })
call s:h("NeomakeErrorSign", { "fg": s:red })
call s:h("NeomakeInfoSign", { "fg": s:blue })

" tpope/vim-fugitive
call s:h("diffAdded", { "fg": s:green })
call s:h("diffRemoved", { "fg": s:red })

" +------------------+
" | Git Highlighting |
" +------------------+

call s:h("gitcommitComment", { "fg": s:comment_grey })
call s:h("gitcommitUnmerged", { "fg": s:green })
call s:h("gitcommitOnBranch", {})
call s:h("gitcommitBranch", { "fg": s:purple })
call s:h("gitcommitDiscardedType", { "fg": s:red })
call s:h("gitcommitSelectedType", { "fg": s:green })
call s:h("gitcommitHeader", {})
call s:h("gitcommitUntrackedFile", { "fg": s:cyan })
call s:h("gitcommitDiscardedFile", { "fg": s:red })
call s:h("gitcommitSelectedFile", { "fg": s:green })
call s:h("gitcommitUnmergedFile", { "fg": s:yellow })
call s:h("gitcommitFile", {})
hi link gitcommitNoBranch gitcommitBranch
hi link gitcommitUntracked gitcommitComment
hi link gitcommitDiscarded gitcommitComment
hi link gitcommitSelected gitcommitComment
hi link gitcommitDiscardedArrow gitcommitDiscardedFile
hi link gitcommitSelectedArrow gitcommitSelectedFile
hi link gitcommitUnmergedArrow gitcommitUnmergedFile

" +------------------------+
" | Neovim terminal colors |
" +------------------------+

if has("nvim")
  let g:terminal_color_0 =  s:black.gui
  let g:terminal_color_1 =  s:red.gui
  let g:terminal_color_2 =  s:green.gui
  let g:terminal_color_3 =  s:yellow.gui
  let g:terminal_color_4 =  s:blue.gui
  let g:terminal_color_5 =  s:purple.gui
  let g:terminal_color_6 =  s:cyan.gui
  let g:terminal_color_7 =  s:white.gui
  let g:terminal_color_8 =  s:visual_grey.gui
  let g:terminal_color_9 =  s:dark_red.gui
  let g:terminal_color_10 = s:green.gui " No dark version
  let g:terminal_color_11 = s:dark_yellow.gui
  let g:terminal_color_12 = s:blue.gui " No dark version
  let g:terminal_color_13 = s:purple.gui " No dark version
  let g:terminal_color_14 = s:cyan.gui " No dark version
  let g:terminal_color_15 = s:comment_grey.gui
  let g:terminal_color_background = g:terminal_color_0
  let g:terminal_color_foreground = g:terminal_color_7
endif
